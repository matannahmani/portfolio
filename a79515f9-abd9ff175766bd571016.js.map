{"version":3,"sources":["webpack:///./node_modules/@egjs/flicking/dist/flicking.esm.js"],"names":["_extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","MOVE_TYPE","DEFAULT_MOVE_TYPE_OPTIONS","snap","type","count","freeScroll","isBrowser","document","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","infinite","infiniteThreshold","lastIndex","Infinity","threshold","duration","panelEffect","x","Math","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","moveType","useOffset","isEqualSize","isConstantSize","renderOnlyVisible","renderExternal","collectStatistics","DEFAULT_VIEWPORT_CSS","position","DEFAULT_CAMERA_CSS","width","height","willChange","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NEED_PANEL","VISIBLE_CHANGE","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","DIRECTION","PREV","NEXT","FLICKING_METHODS","prev","next","moveTo","getIndex","getAllPanels","getCurrentPanel","getElement","getPanel","getPanelCount","getStatus","getVisiblePanels","enableInput","disableInput","destroy","resize","setStatus","isPlaying","_checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","name","has3d","supportedStyle","documentElement","style","transformName","prefixedTransform","Error","el","createElement","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","length","TRANSFORM","merge","target","srcs","_i","arguments","forEach","source","keys","key","value","parseElement","element","isArray","elements","isString","tempDiv","innerHTML","push","apply","toArray","children","firstChild","hasClass","className","classList","contains","split","indexOf","applyCSS","cssObj","property","clamp","val","min","max","isBetween","iterable","slice","call","parseArithmeticExpression","cssValue","base","defaultVal","defaultValue","cssRegex","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","getProgress","pos","range","center","findIndex","callback","i","counter","counterArray","circulate","indexed","size","restoreStyle","originalStyle","setAttribute","removeAttribute","withFlickingMethods","flickingName","args","_a","result","getBbox","bbox","y","offsetWidth","offsetHeight","clientRect","getBoundingClientRect","left","top","Panel","index","viewport","prevSibling","nextSibling","clonedPanels","state","relativeAnchorPosition","isClone","isVirtual","cloneIndex","cachedBbox","setElement","__proto","givenBbox","options","prevSize","panel","cloneState","unCacheBbox","panelCount","panelManager","scrollAreaSize","getScrollAreaSize","floor","getPosition","getCurrentProgress","getOutsetProgress","outsetRange","getSize","getRelativeHangerPosition","getRelativeAnchorPosition","getCameraPosition","getVisibleRatio","panelSize","relativePanelPosition","rightRelativePanelPosition","visibleSize","focus","currentPanel","getHangerPosition","getAnchorPosition","eventType","findEstimatedPosition","update","updateFunction","shouldResize","identicalPanels","getIdenticalPanels","eachPanel","addVisiblePanel","currentIndex","currentPosition","prevPanelIndex","prevPanelPosition","prevPanelSize","hasEmptyPanelBetween","notYetMinPanel","newPosition","prevPanel","clone","getCloneIndex","setPosition","getLastIndex","nextPanelIndex","nextPanelPosition","notYetMaxPanel","nextPanel","parsedElements","firstPanel","targetIndex","insert","insertAfter","remove","option","preserveUI","wasVisible","Boolean","parentNode","cameraElement","getCameraElement","appendChild","getOverlappedClass","classes","classes_1","getClonedPanels","original","concat","getOriginalPanel","setIndex","setPositionCSS","offset","elementStyle","currentElementStyle","styleToApply","cloneElement","cloneNode","clonedPanel","clonedState","removeElement","removeClonedPanelsAfter","start","removingPanels","splice","currentElement","getAttribute","add","replace","addClass","PanelManager","panels","clones","cloneCount","lastPanel","allPanels","reduce","allClones","originalPanels","replacePanels","newPanels","newClones","filter","has","get","getRange","getCloneCount","setLastIndex","possibleLastPanel","shouldRender","setCloneCount","isCircular","findFirstPanelFrom","siblingElement","insertNewPanels","pushedIndex","panelsAfterIndex","emptyPanelCount","removedPanels","newLastIndex","reverse","updateIndex","addNewClones","panelCount_1","cloneSet","replacedPanels","wasNonEmptyCount","deleteCount","deletedPanels","nonEmptyIndexFromLast","chainAllPanels","allPanelsCount","insertClones","insertTarget_1","newClones_1","removeClonesAfter","findPanelOf","allPanels_1","_this","lastPanelClones","nextSiblingClones","_loop_1","cloneNextSibling","lastPanelSibling","cloneSiblingElement","nextElementSibling","map","this_1","insertingIndex","fragment_1","createDocumentFragment","State","delta","direction","targetPanel","lastPosition","onEnter","prevState","onExit","nextState","onHold","e","context","onChange","onRelease","onAnimationEnd","onFinish","IdleState","_super","holding","playing","flicking","triggerEvent","transitTo","moveCamera","onSuccess","onStopped","HoldingState","releaseEvent","inputEvent","offsetX","offsetY","flick","setTo","clickedElement","srcEvent","touch","changedTouches","elementFromPoint","clientX","clientY","clickedPanel","cameraPosition","clickedPanelPosition","DraggingState","stopCamera","absDelta","abs","velocity","velocityX","velocityY","inputDelta","deltaX","deltaY","isNextDirection","swipeDistance","swipeAngle","atan","PI","belowAngleThreshold","overThreshold","moveTypeContext","axesEvent","interruptDestInfo","findPanelWhenInterrupted","destPos","nearestPanel","getNearestPanel","stop","destInfo","findTargetPanel","findRestorePanel","AnimatingState","scrollArea","getScrollArea","loopCount","originalTargetPosition","newCloneIndex","newTargetPosition","newTargetPanel","setCurrentPanel","isTrusted","updateAdaptiveSize","updateCameraPosition","DisabledState","updateAxesPosition","StateMachine","nextStateType","currentState","fire","getState","Snap","ctx","snapCount","eventDelta","minimumDistanceToChange","calcBrinkOfChange","nearestIsCurrent","shouldMoveWhenBounceIs0","canSetBoundMode","shouldMoveToAdjacent","isOutOfBound","findSnappedPanel","findAdjacentPanel","halfGap","estimatedHangerPos","panelToMove","cycleIndex","passedPanelCount","originalPanel","panelPosition","siblingPanel","panelIndex","siblingIndex","originalPosition","defaultDuration","getCurrentIndex","hangerPosition","firstClonedPanel","basePanel","basePosition","adjacentPanel","targetRelativeAnchorPosition","estimatedPosition","MoveType","is","findRestorePanelInCircularMode","lapped","FreeScroll","findNearestPanelAt","stateMachine","currentPanelPosition","lastHangerPosition","Viewport","plugins","panelMaintainRatio","relativeHangerPosition","positionOffset","translate","checkedIndexes","isAdaptiveCached","isViewportGiven","isCameraGiven","originalViewportStyle","originalCameraStyle","visiblePanels","panelBboxes","build","eventResult","axes","findNearestPanel","originalNearestPosition","checkNeedPanel","updateVisiblePanels","posOffset","moveCoord","coord","round","join","viewportElement","updateSize","updateOriginalPanelPositions","updateScrollArea","updateClonePanels","updatePlugins","minimumDistance","prevPosition","nextPosition","distance","minimumAnchorDistance","findNearestIdenticalPanel","nearest","shortestDistance","identical","anchorPosition","findShortestPositionToPanel","getVisibleIndexOf","enable","panInput","disable","resizePanels","newCenterPanel","newPanelPosition","updateCheckedIndexes","indexes","visibleIndex","newCurrentIndex","undefined","shouldApplyAdaptive","viewportStyle","sizeToApply","panelBbox","maximum","viewportBbox","updateBbox","viewportSize","isFreeScroll","plugin","wrapper","removePlugins","topmostElement_1","deletingElement","restore","status","html","refreshPanels","createdPanels","orderedPanels","createdPanel","calcVisiblePanels","cameraPos_1","viewportSize_1","getNext","isOutOfViewport","getAbsIndex_1","nextPanels","prevPanels","sort","panel1","panel2","outsetProgress","NaN","prevRange","nextRange","nearestAnchorPos","nearestIndex","nearestSize","hangerIsNextToNearestPanel","targetPosition","progressBetween","off","on","axesHandlers","getViewportElement","getPositionOffset","getCheckedIndexes","setVisiblePanels","connectAxesHandler","handlers","addPlugins","newPlugins","init","currentPlugins","changedRange","removed","appendUncachedPanelElements","fragment","prevVisiblePanels","equalSizeClasses_1","cached_1","overlappedClass","clonePanels","updateClonedPanelPositions","visiblePanel","setElements","applyCSSValue","setMoveType","setAxesInstance","setDefaultPanel","moveToDefaultPanel","viewportCandidate","hasViewportElement","cameraCandidate","hasCameraElement","child","minHeight","minWidth","easing","interruptable","scale","connect","indexRange","panelAtLeftBoundary","reversedPanels","sumOriginalPanelSize","areaPrev","sizeSum","reversedPanels_1","panelAtRightBoundary","areaNext","panels_1","needCloneOnPrev","ceil","prevCloneCount","origPanel","defaultPanel","defaultPosition","nextPanelPos","maintainingPanel","accumulatedSize","total","clonedPanels_1","clonedPanelPos","lastReplacePosition","_b","replacePosition","relAnchorPosOfCombined","anchorPos","parsedBounce","arr","parsedVal","axis","maxLastIndex","checkingPanel","nextIndex","currentNearestPosition","triggerNeedPanel","firstIndex","lastPanelAfterNeed","cameraPrev","checkingIndex","prevIndex","firstPanelAfterNeed","params","alreadyTriggered","some","hasHandler","hasOn","fill","newVisiblePanels","checkVisiblePanelChange","addedPanels","firstVisiblePanelPos","panelElement","firstVisiblePanel","lastVisiblePanel","getAbsIndex","newVisibleRange","trigger","prevRefCount","newRefCount","newPanel","newIndex","added","equalSizeClasses_2","defaultBbox_1","cid","random","Flicking","isPanelChangedAtBeforeSync","shouldResetElements","parent","origStyle","eventName","canceled","progress","previousPosition","inputOffset","cameraChange","looped","currentDirection","querySelector","nodeName","nodeType","currentOptions","listenInput","listenResize","category","action","label","innerWidth","innerHeight","screen","collectInfos","location","href","navigator","language","toLowerCase","charset","inputEncoding","characterSet","referrer","title","JSON","stringify","req","XMLHttpRequest","open","send","sendEvent","nearestPosition","current","identicals","includeClone","outerHTML","removeEventListener","prepend","append","getRenderingIndexes","diffResult","maintained","values","before","after","prevPanelCount","prevList","list","visibleIndexes","getPanelAbsIndex","renderingPanels","beforeSync","diffInfo","changed","prevClonedPanels","prevOriginalPanels","beforeIdx","afterIdx","addIndex","groupIndex","prevCloneGroup","newCloneGroup","sync","beforeDiffInfo","prevOriginalPanelCount_1","originalPanelCount_1","originalAdded","originalRemoved","addedIndex","addedElement","beforePanel","eventContext","addEventListener","VERSION"],"mappings":"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","file":"a79515f9-abd9ff175766bd571016.js","sourcesContent":["import \"core-js/modules/es6.array.some\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.array.map\";\nimport \"core-js/modules/es6.array.filter\";\nimport \"core-js/modules/es6.array.reduce\";\nimport \"core-js/modules/es6.string.anchor\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.array.index-of\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.array.is-array\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.to-string\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.for-each\";\nimport \"core-js/modules/es6.object.create\";\nimport \"core-js/modules/es6.object.set-prototype-of\";\n\n/*\nCopyright (c) 2015-present NAVER Corp.\nname: @egjs/flicking\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-flicking\nversion: 3.4.7\n*/\nimport Component from '@egjs/component';\nimport Axes, { PanInput } from '@egjs/axes';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar MOVE_TYPE = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\"\n};\nvar DEFAULT_MOVE_TYPE_OPTIONS = {\n  snap: {\n    type: \"snap\",\n    count: 1\n  },\n  freeScroll: {\n    type: \"freeScroll\"\n  }\n};\nvar isBrowser = typeof document !== \"undefined\";\n/**\r\n * Default options for creating Flicking.\r\n * @ko 플리킹을 만들 때 사용하는 기본 옵션들\r\n * @private\r\n * @memberof eg.Flicking\r\n */\n\nvar DEFAULT_OPTIONS = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  infinite: false,\n  infiniteThreshold: 0,\n  lastIndex: Infinity,\n  threshold: 40,\n  duration: 100,\n  panelEffect: function panelEffect(x) {\n    return 1 - Math.pow(1 - x, 3);\n  },\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  moveType: DEFAULT_MOVE_TYPE_OPTIONS.snap,\n  useOffset: false,\n  isEqualSize: false,\n  isConstantSize: false,\n  renderOnlyVisible: false,\n  renderExternal: false,\n  collectStatistics: true\n};\nvar DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  overflow: \"hidden\"\n};\nvar DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\"\n};\nvar DEFAULT_PANEL_CSS = {\n  position: \"absolute\"\n};\nvar EVENTS = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  VISIBLE_CHANGE: \"visibleChange\"\n};\nvar AXES_EVENTS = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\"\n};\nvar STATE_TYPE = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4\n};\nvar DIRECTION = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\"\n};\nvar FLICKING_METHODS = {\n  prev: true,\n  next: true,\n  moveTo: true,\n  getIndex: true,\n  getAllPanels: true,\n  getCurrentPanel: true,\n  getElement: true,\n  getPanel: true,\n  getPanelCount: true,\n  getStatus: true,\n  getVisiblePanels: true,\n  enableInput: true,\n  disableInput: true,\n  destroy: true,\n  resize: true,\n  setStatus: true,\n  isPlaying: true\n}; // Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\n\nvar _checkTranslateSupport = function checkTranslateSupport() {\n  var transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\"\n  };\n\n  if (!isBrowser) {\n    return {\n      name: transforms.transform,\n      has3d: true\n    };\n  }\n\n  var supportedStyle = document.documentElement.style;\n  var transformName = \"\";\n\n  for (var prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  var el = document.createElement(\"div\");\n  document.documentElement.insertBefore(el, null);\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  var styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n  el.parentElement.removeChild(el);\n  var transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\"\n  };\n\n  _checkTranslateSupport = function checkTranslateSupport() {\n    return transformInfo;\n  };\n\n  return transformInfo;\n};\n\nvar TRANSFORM = _checkTranslateSupport();\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nfunction merge(target) {\n  var srcs = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    srcs[_i - 1] = arguments[_i];\n  }\n\n  srcs.forEach(function (source) {\n    Object.keys(source).forEach(function (key) {\n      var value = source[key];\n      target[key] = value;\n    });\n  });\n  return target;\n}\n\nfunction parseElement(element) {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  var elements = [];\n  element.forEach(function (el) {\n    if (isString(el)) {\n      var tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n      elements.push.apply(elements, toArray(tempDiv.children));\n\n      while (tempDiv.firstChild) {\n        tempDiv.removeChild(tempDiv.firstChild);\n      }\n    } else {\n      elements.push(el);\n    }\n  });\n  return elements;\n}\n\nfunction isString(value) {\n  return typeof value === \"string\";\n} // Get class list of element as string array\n\n\nfunction addClass(element, className) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (!hasClass(element, className)) {\n      element.className = (element.className + \" \" + className).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nfunction hasClass(element, className) {\n  if (element.classList) {\n    return element.classList.contains(className);\n  } else {\n    return element.className.split(\" \").indexOf(className) >= 0;\n  }\n}\n\nfunction applyCSS(element, cssObj) {\n  Object.keys(cssObj).forEach(function (property) {\n    element.style[property] = cssObj[property];\n  });\n}\n\nfunction clamp(val, min, max) {\n  return Math.max(Math.min(val, max), min);\n} // Min: inclusive, Max: exclusive\n\n\nfunction isBetween(val, min, max) {\n  return val >= min && val <= max;\n}\n\nfunction toArray(iterable) {\n  return [].slice.call(iterable);\n}\n\nfunction isArray(arr) {\n  return arr && arr.constructor === Array;\n}\n\nfunction parseArithmeticExpression(cssValue, base, defaultVal) {\n  // Set base / 2 to default value, if it's undefined\n  var defaultValue = defaultVal != null ? defaultVal : base / 2;\n  var cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  var idx = 0;\n  var calculatedValue = 0;\n  var matchResult = cssRegex.exec(cssValue);\n\n  while (matchResult != null) {\n    var sign = matchResult[1];\n    var value = matchResult[2];\n    var unit = matchResult[3];\n    var parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    } // Return default value for values not in good form\n\n\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = parsedValue / 100 * base;\n    }\n\n    calculatedValue += sign === \"+\" ? parsedValue : -parsedValue; // Match next occurrence\n\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  } // None-matched\n\n\n  if (idx === 0) {\n    return defaultValue;\n  } // Clamp between 0 ~ base\n\n\n  return clamp(calculatedValue, 0, base);\n}\n\nfunction getProgress(pos, range) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  var min = range[0],\n      center = range[1],\n      max = range[2];\n\n  if (pos > center && max - center) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && center - min) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n\n  return 0;\n}\n\nfunction findIndex(iterable, callback) {\n  for (var i = 0; i < iterable.length; i += 1) {\n    var element = iterable[i];\n\n    if (element && callback(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n} // return [0, 1, ...., max - 1]\n\n\nfunction counter(max) {\n  var counterArray = [];\n\n  for (var i = 0; i < max; i += 1) {\n    counterArray[i] = i;\n  }\n\n  return counterArray;\n} // Circulate number between range [min, max]\n\n/*\r\n * \"indexed\" means min and max is not same, so if it's true \"min - 1\" should be max\r\n * While if it's false, \"min - 1\" should be \"max - 1\"\r\n * use `indexed: true` when it should be used for circulating integers like index\r\n * or `indexed: false` when it should be used for something like positions.\r\n */\n\n\nfunction circulate(value, min, max, indexed) {\n  var size = indexed ? max - min + 1 : max - min;\n\n  if (value < min) {\n    var offset = indexed ? (min - value - 1) % size : (min - value) % size;\n    value = max - offset;\n  } else if (value > max) {\n    var offset = indexed ? (value - max - 1) % size : (value - max) % size;\n    value = min + offset;\n  }\n\n  return value;\n}\n\nfunction restoreStyle(element, originalStyle) {\n  originalStyle.className ? element.setAttribute(\"class\", originalStyle.className) : element.removeAttribute(\"class\");\n  originalStyle.style ? element.setAttribute(\"style\", originalStyle.style) : element.removeAttribute(\"style\");\n}\n/**\r\n * Decorator that makes the method of flicking available in the framework.\r\n * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.\r\n * @memberof eg.Flicking\r\n * @private\r\n * @example\r\n * ```js\r\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\r\n *\r\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\r\n *   &#64;withFlickingMethods\r\n *   private flicking: Flicking;\r\n * }\r\n * ```\r\n */\n\n\nfunction withFlickingMethods(prototype, flickingName) {\n  Object.keys(FLICKING_METHODS).forEach(function (name) {\n    if (prototype[name]) {\n      return;\n    }\n\n    prototype[name] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var result = (_a = this[flickingName])[name].apply(_a, args); // fix `this` type to return your own `flicking` instance to the instance using the decorator.\n\n\n      if (result === this[flickingName]) {\n        return this;\n      } else {\n        return result;\n      }\n\n      var _a;\n    };\n  });\n}\n\nfunction getBbox(element, useOffset) {\n  var bbox;\n\n  if (useOffset) {\n    bbox = {\n      x: 0,\n      y: 0,\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  } else {\n    var clientRect = element.getBoundingClientRect();\n    bbox = {\n      x: clientRect.left,\n      y: clientRect.top,\n      width: clientRect.width,\n      height: clientRect.height\n    };\n  }\n\n  return bbox;\n}\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar Panel = /*#__PURE__*/function () {\n  function Panel(element, index, viewport) {\n    this.viewport = viewport;\n    this.prevSibling = null;\n    this.nextSibling = null;\n    this.clonedPanels = [];\n    this.state = {\n      index: index,\n      position: 0,\n      relativeAnchorPosition: 0,\n      size: 0,\n      isClone: false,\n      isVirtual: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: \"\",\n        style: \"\"\n      },\n      cachedBbox: null\n    };\n    this.setElement(element);\n  }\n\n  var __proto = Panel.prototype;\n\n  __proto.resize = function (givenBbox) {\n    var state = this.state;\n    var options = this.viewport.options;\n    var bbox = givenBbox ? givenBbox : this.getBbox();\n    this.state.cachedBbox = bbox;\n    var prevSize = state.size;\n    state.size = options.horizontal ? bbox.width : bbox.height;\n\n    if (prevSize !== state.size) {\n      state.relativeAnchorPosition = parseArithmeticExpression(options.anchor, state.size);\n    }\n\n    if (!state.isClone) {\n      this.clonedPanels.forEach(function (panel) {\n        var cloneState = panel.state;\n        cloneState.size = state.size;\n        cloneState.cachedBbox = state.cachedBbox;\n        cloneState.relativeAnchorPosition = state.relativeAnchorPosition;\n      });\n    }\n  };\n\n  __proto.unCacheBbox = function () {\n    this.state.cachedBbox = null;\n  };\n\n  __proto.getProgress = function () {\n    var viewport = this.viewport;\n    var options = viewport.options;\n    var panelCount = viewport.panelManager.getPanelCount();\n    var scrollAreaSize = viewport.getScrollAreaSize();\n    var relativeIndex = (options.circular ? Math.floor(this.getPosition() / scrollAreaSize) * panelCount : 0) + this.getIndex();\n    var progress = relativeIndex - viewport.getCurrentProgress();\n    return progress;\n  };\n\n  __proto.getOutsetProgress = function () {\n    var viewport = this.viewport;\n    var outsetRange = [-this.getSize(), viewport.getRelativeHangerPosition() - this.getRelativeAnchorPosition(), viewport.getSize()];\n    var relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    var outsetProgress = getProgress(relativePanelPosition, outsetRange);\n    return outsetProgress;\n  };\n\n  __proto.getVisibleRatio = function () {\n    var viewport = this.viewport;\n    var panelSize = this.getSize();\n    var relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    var rightRelativePanelPosition = relativePanelPosition + panelSize;\n    var visibleSize = Math.min(viewport.getSize(), rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n    var visibleRatio = visibleSize >= 0 ? visibleSize / panelSize : 0;\n    return visibleRatio;\n  };\n\n  __proto.focus = function (duration) {\n    var viewport = this.viewport;\n    var currentPanel = viewport.getCurrentPanel();\n    var hangerPosition = viewport.getHangerPosition();\n    var anchorPosition = this.getAnchorPosition();\n\n    if (hangerPosition === anchorPosition || !currentPanel) {\n      return;\n    }\n\n    var currentPosition = currentPanel.getPosition();\n    var eventType = currentPosition === this.getPosition() ? \"\" : EVENTS.CHANGE;\n    viewport.moveTo(this, viewport.findEstimatedPosition(this), eventType, null, duration);\n  };\n\n  __proto.update = function (updateFunction, shouldResize) {\n    if (updateFunction === void 0) {\n      updateFunction = null;\n    }\n\n    if (shouldResize === void 0) {\n      shouldResize = true;\n    }\n\n    var identicalPanels = this.getIdenticalPanels();\n\n    if (updateFunction) {\n      identicalPanels.forEach(function (eachPanel) {\n        updateFunction(eachPanel.getElement());\n      });\n    }\n\n    if (shouldResize) {\n      identicalPanels.forEach(function (eachPanel) {\n        eachPanel.unCacheBbox();\n      });\n      this.viewport.addVisiblePanel(this);\n      this.viewport.resize();\n    }\n  };\n\n  __proto.prev = function () {\n    var viewport = this.viewport;\n    var options = viewport.options;\n    var prevSibling = this.prevSibling;\n\n    if (!prevSibling) {\n      return null;\n    }\n\n    var currentIndex = this.getIndex();\n    var currentPosition = this.getPosition();\n    var prevPanelIndex = prevSibling.getIndex();\n    var prevPanelPosition = prevSibling.getPosition();\n    var prevPanelSize = prevSibling.getSize();\n    var hasEmptyPanelBetween = currentIndex - prevPanelIndex > 1;\n    var notYetMinPanel = options.infinite && currentIndex > 0 && prevPanelIndex > currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMinPanel) {\n      // Empty panel exists between\n      return null;\n    }\n\n    var newPosition = currentPosition - prevPanelSize - options.gap;\n    var prevPanel = prevSibling;\n\n    if (prevPanelPosition !== newPosition) {\n      prevPanel = prevSibling.clone(prevSibling.getCloneIndex(), true);\n      prevPanel.setPosition(newPosition);\n    }\n\n    return prevPanel;\n  };\n\n  __proto.next = function () {\n    var viewport = this.viewport;\n    var options = viewport.options;\n    var nextSibling = this.nextSibling;\n    var lastIndex = viewport.panelManager.getLastIndex();\n\n    if (!nextSibling) {\n      return null;\n    }\n\n    var currentIndex = this.getIndex();\n    var currentPosition = this.getPosition();\n    var nextPanelIndex = nextSibling.getIndex();\n    var nextPanelPosition = nextSibling.getPosition();\n    var hasEmptyPanelBetween = nextPanelIndex - currentIndex > 1;\n    var notYetMaxPanel = options.infinite && currentIndex < lastIndex && nextPanelIndex < currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMaxPanel) {\n      return null;\n    }\n\n    var newPosition = currentPosition + this.getSize() + options.gap;\n    var nextPanel = nextSibling;\n\n    if (nextPanelPosition !== newPosition) {\n      nextPanel = nextSibling.clone(nextSibling.getCloneIndex(), true);\n      nextPanel.setPosition(newPosition);\n    }\n\n    return nextPanel;\n  };\n\n  __proto.insertBefore = function (element) {\n    var viewport = this.viewport;\n    var parsedElements = parseElement(element);\n    var firstPanel = viewport.panelManager.firstPanel();\n    var prevSibling = this.prevSibling; // Finding correct inserting index\n    // While it should insert removing empty spaces,\n    // It also should have to be bigger than prevSibling' s index\n\n    var targetIndex = prevSibling && firstPanel.getIndex() !== this.getIndex() ? Math.max(prevSibling.getIndex() + 1, this.getIndex() - parsedElements.length) : Math.max(this.getIndex() - parsedElements.length, 0);\n    return viewport.insert(targetIndex, parsedElements);\n  };\n\n  __proto.insertAfter = function (element) {\n    return this.viewport.insert(this.getIndex() + 1, element);\n  };\n\n  __proto.remove = function () {\n    this.viewport.remove(this.getIndex());\n    return this;\n  };\n\n  __proto.destroy = function (option) {\n    if (!option.preserveUI) {\n      var originalStyle = this.state.originalStyle;\n      restoreStyle(this.element, originalStyle);\n    } // release resources\n\n\n    for (var x in this) {\n      this[x] = null;\n    }\n  };\n\n  __proto.getElement = function () {\n    return this.element;\n  };\n\n  __proto.getAnchorPosition = function () {\n    return this.state.position + this.state.relativeAnchorPosition;\n  };\n\n  __proto.getRelativeAnchorPosition = function () {\n    return this.state.relativeAnchorPosition;\n  };\n\n  __proto.getIndex = function () {\n    return this.state.index;\n  };\n\n  __proto.getPosition = function () {\n    return this.state.position;\n  };\n\n  __proto.getSize = function () {\n    return this.state.size;\n  };\n\n  __proto.getBbox = function () {\n    var state = this.state;\n    var viewport = this.viewport;\n    var element = this.element;\n    var options = viewport.options;\n\n    if (!element) {\n      state.cachedBbox = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    } else if (!state.cachedBbox) {\n      var wasVisible = Boolean(element.parentNode);\n      var cameraElement = viewport.getCameraElement();\n\n      if (!wasVisible) {\n        cameraElement.appendChild(element);\n        viewport.addVisiblePanel(this);\n      }\n\n      state.cachedBbox = getBbox(element, options.useOffset);\n\n      if (!wasVisible && viewport.options.renderExternal) {\n        cameraElement.removeChild(element);\n      }\n    }\n\n    return state.cachedBbox;\n  };\n\n  __proto.isClone = function () {\n    return this.state.isClone;\n  };\n\n  __proto.getOverlappedClass = function (classes) {\n    var element = this.element;\n\n    for (var _i = 0, classes_1 = classes; _i < classes_1.length; _i++) {\n      var className = classes_1[_i];\n\n      if (hasClass(element, className)) {\n        return className;\n      }\n    }\n  };\n\n  __proto.getCloneIndex = function () {\n    return this.state.cloneIndex;\n  };\n\n  __proto.getClonedPanels = function () {\n    var state = this.state;\n    return state.isClone ? this.original.getClonedPanels() : this.clonedPanels;\n  };\n\n  __proto.getIdenticalPanels = function () {\n    var state = this.state;\n    return state.isClone ? this.original.getIdenticalPanels() : [this].concat(this.clonedPanels);\n  };\n\n  __proto.getOriginalPanel = function () {\n    return this.state.isClone ? this.original : this;\n  };\n\n  __proto.setIndex = function (index) {\n    var state = this.state;\n    state.index = index;\n    this.clonedPanels.forEach(function (panel) {\n      return panel.state.index = index;\n    });\n  };\n\n  __proto.setPosition = function (pos) {\n    this.state.position = pos;\n    return this;\n  };\n\n  __proto.setPositionCSS = function (offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (!this.element) {\n      return;\n    }\n\n    var state = this.state;\n    var pos = state.position;\n    var options = this.viewport.options;\n    var elementStyle = this.element.style;\n    var currentElementStyle = options.horizontal ? elementStyle.left : elementStyle.top;\n    var styleToApply = pos - offset + \"px\";\n\n    if (!state.isVirtual && currentElementStyle !== styleToApply) {\n      options.horizontal ? elementStyle.left = styleToApply : elementStyle.top = styleToApply;\n    }\n  };\n\n  __proto.clone = function (cloneIndex, isVirtual, element) {\n    if (isVirtual === void 0) {\n      isVirtual = false;\n    }\n\n    var state = this.state;\n    var viewport = this.viewport;\n    var cloneElement = element;\n\n    if (!cloneElement && this.element) {\n      cloneElement = isVirtual ? this.element : this.element.cloneNode(true);\n    }\n\n    var clonedPanel = new Panel(cloneElement, state.index, viewport);\n    var clonedState = clonedPanel.state;\n    clonedPanel.original = state.isClone ? this.original : this;\n    clonedState.isClone = true;\n    clonedState.isVirtual = isVirtual;\n    clonedState.cloneIndex = cloneIndex; // Inherit some state values\n\n    clonedState.size = state.size;\n    clonedState.relativeAnchorPosition = state.relativeAnchorPosition;\n    clonedState.originalStyle = state.originalStyle;\n    clonedState.cachedBbox = state.cachedBbox;\n\n    if (!isVirtual) {\n      this.clonedPanels.push(clonedPanel);\n    } else {\n      clonedPanel.prevSibling = this.prevSibling;\n      clonedPanel.nextSibling = this.nextSibling;\n    }\n\n    return clonedPanel;\n  };\n\n  __proto.removeElement = function () {\n    if (!this.viewport.options.renderExternal) {\n      var element = this.element;\n      element.parentNode && element.parentNode.removeChild(element);\n    } // Do the same thing for clones\n\n\n    if (!this.state.isClone) {\n      this.removeClonedPanelsAfter(0);\n    }\n  };\n\n  __proto.removeClonedPanelsAfter = function (start) {\n    var options = this.viewport.options;\n    var removingPanels = this.clonedPanels.splice(start);\n\n    if (!options.renderExternal) {\n      removingPanels.forEach(function (panel) {\n        panel.removeElement();\n      });\n    }\n  };\n\n  __proto.setElement = function (element) {\n    if (!element) {\n      return;\n    }\n\n    var currentElement = this.element;\n\n    if (element !== currentElement) {\n      var options = this.viewport.options;\n\n      if (currentElement) {\n        if (options.horizontal) {\n          element.style.left = currentElement.style.left;\n        } else {\n          element.style.top = currentElement.style.top;\n        }\n      } else {\n        var originalStyle = this.state.originalStyle;\n        originalStyle.className = element.getAttribute(\"class\");\n        originalStyle.style = element.getAttribute(\"style\");\n      }\n\n      this.element = element;\n\n      if (options.classPrefix) {\n        addClass(element, options.classPrefix + \"-panel\");\n      } // Update size info after applying panel css\n\n\n      applyCSS(this.element, DEFAULT_PANEL_CSS);\n    }\n  };\n\n  return Panel;\n}();\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar PanelManager = /*#__PURE__*/function () {\n  function PanelManager(cameraElement, options) {\n    this.cameraElement = cameraElement;\n    this.panels = [];\n    this.clones = [];\n    this.range = {\n      min: -1,\n      max: -1\n    };\n    this.length = 0;\n    this.cloneCount = 0;\n    this.options = options;\n    this.lastIndex = options.lastIndex;\n  }\n\n  var __proto = PanelManager.prototype;\n\n  __proto.firstPanel = function () {\n    return this.panels[this.range.min];\n  };\n\n  __proto.lastPanel = function () {\n    return this.panels[this.range.max];\n  };\n\n  __proto.allPanels = function () {\n    return this.panels.concat(this.clones.reduce(function (allClones, clones) {\n      return allClones.concat(clones);\n    }, []));\n  };\n\n  __proto.originalPanels = function () {\n    return this.panels;\n  };\n\n  __proto.clonedPanels = function () {\n    return this.clones;\n  };\n\n  __proto.replacePanels = function (newPanels, newClones) {\n    this.panels = newPanels;\n    this.clones = newClones;\n    this.range = {\n      min: findIndex(newPanels, function (panel) {\n        return Boolean(panel);\n      }),\n      max: newPanels.length - 1\n    };\n    this.length = newPanels.filter(function (panel) {\n      return Boolean(panel);\n    }).length;\n  };\n\n  __proto.has = function (index) {\n    return !!this.panels[index];\n  };\n\n  __proto.get = function (index) {\n    return this.panels[index];\n  };\n\n  __proto.getPanelCount = function () {\n    return this.length;\n  };\n\n  __proto.getLastIndex = function () {\n    return this.lastIndex;\n  };\n\n  __proto.getRange = function () {\n    return this.range;\n  };\n\n  __proto.getCloneCount = function () {\n    return this.cloneCount;\n  };\n\n  __proto.setLastIndex = function (lastIndex) {\n    this.lastIndex = lastIndex;\n    var firstPanel = this.firstPanel();\n    var lastPanel = this.lastPanel();\n\n    if (!firstPanel || !lastPanel) {\n      return; // no meaning of updating range & length\n    } // Remove panels above new last index\n\n\n    var range = this.range;\n\n    if (lastPanel.getIndex() > lastIndex) {\n      var removingPanels = this.panels.splice(lastIndex + 1);\n      this.length -= removingPanels.length;\n      var firstRemovedPanel = removingPanels.filter(function (panel) {\n        return !!panel;\n      })[0];\n      var possibleLastPanel = firstRemovedPanel.prevSibling;\n\n      if (possibleLastPanel) {\n        range.max = possibleLastPanel.getIndex();\n      } else {\n        range.min = -1;\n        range.max = -1;\n      }\n\n      if (this.shouldRender()) {\n        removingPanels.forEach(function (panel) {\n          return panel.removeElement();\n        });\n      }\n    }\n  };\n\n  __proto.setCloneCount = function (cloneCount) {\n    this.cloneCount = cloneCount;\n  }; // Insert at index\n  // Returns pushed elements from index, inserting at 'empty' position doesn't push elements behind it\n\n\n  __proto.insert = function (index, newPanels) {\n    var panels = this.panels;\n    var range = this.range;\n    var isCircular = this.options.circular;\n    var lastIndex = this.lastIndex; // Find first panel that index is greater than inserting index\n\n    var nextSibling = this.findFirstPanelFrom(index); // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n\n    var firstPanel = this.firstPanel();\n    var siblingElement = nextSibling ? nextSibling.getElement() : isCircular && firstPanel ? firstPanel.getClonedPanels()[0].getElement() : null; // Insert panels before sibling element\n\n    this.insertNewPanels(newPanels, siblingElement);\n    var pushedIndex = newPanels.length; // Like when setting index 50 while visible panels are 0, 1, 2\n\n    if (index > range.max) {\n      newPanels.forEach(function (panel, offset) {\n        panels[index + offset] = panel;\n      });\n    } else {\n      var panelsAfterIndex = panels.slice(index, index + newPanels.length); // Find empty from beginning\n\n      var emptyPanelCount = findIndex(panelsAfterIndex, function (panel) {\n        return !!panel;\n      });\n\n      if (emptyPanelCount < 0) {\n        // All empty\n        emptyPanelCount = panelsAfterIndex.length;\n      }\n\n      pushedIndex = newPanels.length - emptyPanelCount; // Insert removing empty panels\n\n      panels.splice.apply(panels, [index, emptyPanelCount].concat(newPanels)); // Remove panels after last index\n\n      if (panels.length > lastIndex + 1) {\n        var removedPanels = panels.splice(lastIndex + 1).filter(function (panel) {\n          return Boolean(panel);\n        });\n        this.length -= removedPanels.length; // Find first\n\n        var newLastIndex = lastIndex - findIndex(this.panels.concat().reverse(), function (panel) {\n          return !!panel;\n        }); // Can be filled with empty after newLastIndex\n\n        this.panels.splice(newLastIndex + 1);\n        this.range.max = newLastIndex;\n\n        if (this.shouldRender()) {\n          removedPanels.forEach(function (panel) {\n            return panel.removeElement();\n          });\n        }\n      }\n    } // Update index of previous panels\n\n\n    if (pushedIndex > 0) {\n      panels.slice(index + newPanels.length).forEach(function (panel) {\n        panel.setIndex(panel.getIndex() + pushedIndex);\n      });\n    } // Update state\n\n\n    this.length += newPanels.length;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length - pushedIndex, nextSibling);\n      var clones = this.clones;\n      var panelCount_1 = this.panels.length;\n\n      if (clones[0] && clones[0].length > lastIndex + 1) {\n        clones.forEach(function (cloneSet) {\n          cloneSet.splice(panelCount_1);\n        });\n      }\n    }\n\n    return pushedIndex;\n  };\n\n  __proto.replace = function (index, newPanels) {\n    var panels = this.panels;\n    var range = this.range;\n    var options = this.options;\n    var isCircular = options.circular; // Find first panel that index is greater than inserting index\n\n    var nextSibling = this.findFirstPanelFrom(index + newPanels.length); // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n\n    var firstPanel = this.firstPanel();\n    var siblingElement = nextSibling ? nextSibling.getElement() : isCircular && firstPanel ? firstPanel.getClonedPanels()[0].getElement() : null; // Insert panels before sibling element\n\n    this.insertNewPanels(newPanels, siblingElement);\n\n    if (index > range.max) {\n      // Temporarily insert null at index to use splice()\n      panels[index] = null;\n    }\n\n    var replacedPanels = panels.splice.apply(panels, [index, newPanels.length].concat(newPanels));\n    var wasNonEmptyCount = replacedPanels.filter(function (panel) {\n      return Boolean(panel);\n    }).length; // Suppose inserting [1, 2, 3] at 0 position when there were [empty, 1]\n    // So length should be increased by 3(inserting panels) - 1(non-empty panels)\n\n    this.length += newPanels.length - wasNonEmptyCount;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length, nextSibling);\n    }\n\n    if (this.shouldRender()) {\n      replacedPanels.forEach(function (panel) {\n        return panel && panel.removeElement();\n      });\n    }\n\n    return replacedPanels;\n  };\n\n  __proto.remove = function (index, deleteCount) {\n    if (deleteCount === void 0) {\n      deleteCount = 1;\n    }\n\n    var isCircular = this.options.circular;\n    var panels = this.panels;\n    var clones = this.clones; // Delete count should be equal or larger than 0\n\n    deleteCount = Math.max(deleteCount, 0);\n    var deletedPanels = panels.splice(index, deleteCount).filter(function (panel) {\n      return !!panel;\n    });\n\n    if (this.shouldRender()) {\n      deletedPanels.forEach(function (panel) {\n        return panel.removeElement();\n      });\n    }\n\n    if (isCircular) {\n      clones.forEach(function (cloneSet) {\n        cloneSet.splice(index, deleteCount);\n      });\n    } // Update indexes\n\n\n    panels.slice(index).forEach(function (panel) {\n      panel.setIndex(panel.getIndex() - deleteCount);\n    }); // Check last panel is empty\n\n    var lastIndex = panels.length - 1;\n\n    if (!panels[lastIndex]) {\n      var reversedPanels = panels.concat().reverse();\n      var nonEmptyIndexFromLast = findIndex(reversedPanels, function (panel) {\n        return !!panel;\n      });\n      lastIndex = nonEmptyIndexFromLast < 0 ? -1 // All empty\n      : lastIndex - nonEmptyIndexFromLast; // Remove all empty panels from last\n\n      panels.splice(lastIndex + 1);\n\n      if (isCircular) {\n        clones.forEach(function (cloneSet) {\n          cloneSet.splice(lastIndex + 1);\n        });\n      }\n    } // Update range & length\n\n\n    this.range = {\n      min: findIndex(panels, function (panel) {\n        return !!panel;\n      }),\n      max: lastIndex\n    };\n    this.length -= deletedPanels.length;\n\n    if (this.length <= 0) {\n      // Reset clones\n      this.clones = [];\n      this.cloneCount = 0;\n    }\n\n    return deletedPanels;\n  };\n\n  __proto.chainAllPanels = function () {\n    var allPanels = this.allPanels().filter(function (panel) {\n      return !!panel;\n    });\n    var allPanelsCount = allPanels.length;\n\n    if (allPanelsCount <= 1) {\n      return;\n    }\n\n    allPanels.slice(1, allPanels.length - 1).forEach(function (panel, idx) {\n      var prevPanel = allPanels[idx];\n      var nextPanel = allPanels[idx + 2];\n      panel.prevSibling = prevPanel;\n      panel.nextSibling = nextPanel;\n    });\n    var firstPanel = allPanels[0];\n    var lastPanel = allPanels[allPanelsCount - 1];\n    firstPanel.prevSibling = null;\n    firstPanel.nextSibling = allPanels[1];\n    lastPanel.prevSibling = allPanels[allPanelsCount - 2];\n    lastPanel.nextSibling = null;\n\n    if (this.options.circular) {\n      firstPanel.prevSibling = lastPanel;\n      lastPanel.nextSibling = firstPanel;\n    }\n  };\n\n  __proto.insertClones = function (cloneIndex, index, clonedPanels, deleteCount) {\n    if (deleteCount === void 0) {\n      deleteCount = 0;\n    }\n\n    var clones = this.clones;\n    var lastIndex = this.lastIndex;\n\n    if (!clones[cloneIndex]) {\n      var newClones_1 = [];\n      clonedPanels.forEach(function (panel, offset) {\n        newClones_1[index + offset] = panel;\n      });\n      clones[cloneIndex] = newClones_1;\n    } else {\n      var insertTarget_1 = clones[cloneIndex];\n\n      if (index >= insertTarget_1.length) {\n        clonedPanels.forEach(function (panel, offset) {\n          insertTarget_1[index + offset] = panel;\n        });\n      } else {\n        insertTarget_1.splice.apply(insertTarget_1, [index, deleteCount].concat(clonedPanels)); // Remove panels after last index\n\n        if (clonedPanels.length > lastIndex + 1) {\n          clonedPanels.splice(lastIndex + 1);\n        }\n      }\n    }\n  }; // clones are operating in set\n\n\n  __proto.removeClonesAfter = function (cloneIndex) {\n    var panels = this.panels;\n    panels.forEach(function (panel) {\n      panel.removeClonedPanelsAfter(cloneIndex);\n    });\n    this.clones.splice(cloneIndex);\n  };\n\n  __proto.findPanelOf = function (element) {\n    var allPanels = this.allPanels();\n\n    for (var _i = 0, allPanels_1 = allPanels; _i < allPanels_1.length; _i++) {\n      var panel = allPanels_1[_i];\n\n      if (!panel) {\n        continue;\n      }\n\n      var panelElement = panel.getElement();\n\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  };\n\n  __proto.findFirstPanelFrom = function (index) {\n    for (var _i = 0, _a = this.panels.slice(index); _i < _a.length; _i++) {\n      var panel = _a[_i];\n\n      if (panel && panel.getIndex() >= index && panel.getElement().parentNode) {\n        return panel;\n      }\n    }\n  };\n\n  __proto.addNewClones = function (index, originalPanels, deleteCount, nextSibling) {\n    var _this = this;\n\n    var cameraElement = this.cameraElement;\n    var cloneCount = this.getCloneCount();\n    var lastPanel = this.lastPanel();\n    var lastPanelClones = lastPanel ? lastPanel.getClonedPanels() : [];\n    var nextSiblingClones = nextSibling ? nextSibling.getClonedPanels() : [];\n\n    var _loop_1 = function _loop_1(cloneIndex) {\n      var cloneNextSibling = nextSiblingClones[cloneIndex];\n      var lastPanelSibling = lastPanelClones[cloneIndex];\n      var cloneSiblingElement = cloneNextSibling ? cloneNextSibling.getElement() : lastPanelSibling ? lastPanelSibling.getElement().nextElementSibling : null;\n      var newClones = originalPanels.map(function (panel) {\n        var clone = panel.clone(cloneIndex);\n\n        if (_this.shouldRender()) {\n          cameraElement.insertBefore(clone.getElement(), cloneSiblingElement);\n        }\n\n        return clone;\n      });\n      this_1.insertClones(cloneIndex, index, newClones, deleteCount);\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, _a = counter(cloneCount); _i < _a.length; _i++) {\n      var cloneIndex = _a[_i];\n\n      _loop_1(cloneIndex);\n    }\n  };\n\n  __proto.updateIndex = function (insertingIndex) {\n    var panels = this.panels;\n    var range = this.range;\n    var newLastIndex = panels.length - 1;\n\n    if (newLastIndex > range.max) {\n      range.max = newLastIndex;\n    }\n\n    if (insertingIndex < range.min || range.min < 0) {\n      range.min = insertingIndex;\n    }\n  };\n\n  __proto.insertNewPanels = function (newPanels, siblingElement) {\n    if (this.shouldRender()) {\n      var fragment_1 = document.createDocumentFragment();\n      newPanels.forEach(function (panel) {\n        return fragment_1.appendChild(panel.getElement());\n      });\n      this.cameraElement.insertBefore(fragment_1, siblingElement);\n    }\n  };\n\n  __proto.shouldRender = function () {\n    var options = this.options;\n    return !options.renderExternal && !options.renderOnlyVisible;\n  };\n\n  return PanelManager;\n}();\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar State = /*#__PURE__*/function () {\n  function State() {\n    this.delta = 0;\n    this.direction = null;\n    this.targetPanel = null;\n    this.lastPosition = 0;\n  }\n\n  var __proto = State.prototype;\n\n  __proto.onEnter = function (prevState) {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n    this.lastPosition = prevState.lastPosition;\n  };\n\n  __proto.onExit = function (nextState) {// DO NOTHING\n  };\n\n  __proto.onHold = function (e, context) {// DO NOTHING\n  };\n\n  __proto.onChange = function (e, context) {// DO NOTHING\n  };\n\n  __proto.onRelease = function (e, context) {// DO NOTHING\n  };\n\n  __proto.onAnimationEnd = function (e, context) {// DO NOTHING\n  };\n\n  __proto.onFinish = function (e, context) {// DO NOTHING\n  };\n\n  return State;\n}();\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar IdleState = /*#__PURE__*/function (_super) {\n  __extends(IdleState, _super);\n\n  function IdleState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = STATE_TYPE.IDLE;\n    _this.holding = false;\n    _this.playing = false;\n    return _this;\n  }\n\n  var __proto = IdleState.prototype;\n\n  __proto.onEnter = function () {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n    this.lastPosition = 0;\n  };\n\n  __proto.onHold = function (e, _a) {\n    var flicking = _a.flicking,\n        viewport = _a.viewport,\n        triggerEvent = _a.triggerEvent,\n        transitTo = _a.transitTo; // Shouldn't do any action until any panels on flicking area\n\n    if (flicking.getPanelCount() <= 0) {\n      if (viewport.options.infinite) {\n        viewport.moveCamera(viewport.getCameraPosition(), e);\n      }\n\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    this.lastPosition = viewport.getCameraPosition();\n    triggerEvent(EVENTS.HOLD_START, e, true).onSuccess(function () {\n      transitTo(STATE_TYPE.HOLDING);\n    }).onStopped(function () {\n      transitTo(STATE_TYPE.DISABLED);\n    });\n  }; // By methods call\n\n\n  __proto.onChange = function (e, context) {\n    var triggerEvent = context.triggerEvent,\n        transitTo = context.transitTo;\n    triggerEvent(EVENTS.MOVE_START, e, false).onSuccess(function () {\n      // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.ANIMATING).onChange(e, context);\n    }).onStopped(function () {\n      transitTo(STATE_TYPE.DISABLED);\n    });\n  };\n\n  return IdleState;\n}(State);\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar HoldingState = /*#__PURE__*/function (_super) {\n  __extends(HoldingState, _super);\n\n  function HoldingState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = STATE_TYPE.HOLDING;\n    _this.holding = true;\n    _this.playing = true;\n    _this.releaseEvent = null;\n    return _this;\n  }\n\n  var __proto = HoldingState.prototype;\n\n  __proto.onChange = function (e, context) {\n    var flicking = context.flicking,\n        triggerEvent = context.triggerEvent,\n        transitTo = context.transitTo;\n    var offset = flicking.options.horizontal ? e.inputEvent.offsetX : e.inputEvent.offsetY;\n    this.direction = offset < 0 ? DIRECTION.NEXT : DIRECTION.PREV;\n    triggerEvent(EVENTS.MOVE_START, e, true).onSuccess(function () {\n      // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.DRAGGING).onChange(e, context);\n    }).onStopped(function () {\n      transitTo(STATE_TYPE.DISABLED);\n    });\n  };\n\n  __proto.onRelease = function (e, context) {\n    var viewport = context.viewport,\n        triggerEvent = context.triggerEvent,\n        transitTo = context.transitTo;\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      e.setTo({\n        flick: viewport.getCameraPosition()\n      }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    } // Can't handle select event here,\n    // As \"finish\" axes event happens\n\n\n    this.releaseEvent = e;\n  };\n\n  __proto.onFinish = function (e, _a) {\n    var viewport = _a.viewport,\n        triggerEvent = _a.triggerEvent,\n        transitTo = _a.transitTo; // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    } // Handle release event here\n    // To prevent finish event called twice\n\n\n    var releaseEvent = this.releaseEvent; // Static click\n\n    var srcEvent = releaseEvent.inputEvent.srcEvent;\n    var clickedElement;\n\n    if (srcEvent.type === \"touchend\") {\n      var touchEvent = srcEvent;\n      var touch = touchEvent.changedTouches[0];\n      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY);\n    } else {\n      clickedElement = srcEvent.target;\n    }\n\n    var clickedPanel = viewport.panelManager.findPanelOf(clickedElement);\n    var cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      var clickedPanelPosition = clickedPanel.getPosition();\n      var direction = clickedPanelPosition > cameraPosition ? DIRECTION.NEXT : clickedPanelPosition < cameraPosition ? DIRECTION.PREV : null; // Don't provide axes event, to use axes instance instead\n\n      triggerEvent(EVENTS.SELECT, null, true, {\n        direction: direction,\n        index: clickedPanel.getIndex(),\n        panel: clickedPanel\n      });\n    }\n  };\n\n  return HoldingState;\n}(State);\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar DraggingState = /*#__PURE__*/function (_super) {\n  __extends(DraggingState, _super);\n\n  function DraggingState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = STATE_TYPE.DRAGGING;\n    _this.holding = true;\n    _this.playing = true;\n    return _this;\n  }\n\n  var __proto = DraggingState.prototype;\n\n  __proto.onChange = function (e, _a) {\n    var moveCamera = _a.moveCamera,\n        transitTo = _a.transitTo;\n\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e).onStopped(function () {\n      transitTo(STATE_TYPE.DISABLED);\n    });\n  };\n\n  __proto.onRelease = function (e, context) {\n    var flicking = context.flicking,\n        viewport = context.viewport,\n        triggerEvent = context.triggerEvent,\n        transitTo = context.transitTo,\n        stopCamera = context.stopCamera;\n    var delta = this.delta;\n    var absDelta = Math.abs(delta);\n    var options = flicking.options;\n    var horizontal = options.horizontal;\n    var moveType = viewport.moveType;\n    var inputEvent = e.inputEvent;\n    var velocity = horizontal ? inputEvent.velocityX : inputEvent.velocityY;\n    var inputDelta = horizontal ? inputEvent.deltaX : inputEvent.deltaY;\n    var isNextDirection = Math.abs(velocity) > 1 ? velocity < 0 : absDelta > 0 ? delta > 0 : inputDelta < 0;\n    var swipeDistance = viewport.options.bound ? Math.max(absDelta, Math.abs(inputDelta)) : absDelta;\n    var swipeAngle = inputEvent.deltaX ? Math.abs(180 * Math.atan(inputEvent.deltaY / inputEvent.deltaX) / Math.PI) : 90;\n    var belowAngleThreshold = horizontal ? swipeAngle <= options.thresholdAngle : swipeAngle > options.thresholdAngle;\n    var overThreshold = swipeDistance >= options.threshold && belowAngleThreshold;\n    var moveTypeContext = {\n      viewport: viewport,\n      axesEvent: e,\n      state: this,\n      swipeDistance: swipeDistance,\n      isNextDirection: isNextDirection\n    }; // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n    var targetPanel = this.targetPanel;\n\n    if (!overThreshold && targetPanel) {\n      // Interrupted while animating\n      var interruptDestInfo = moveType.findPanelWhenInterrupted(moveTypeContext);\n      viewport.moveTo(interruptDestInfo.panel, interruptDestInfo.destPos, interruptDestInfo.eventType, e, interruptDestInfo.duration);\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    var currentPanel = viewport.getCurrentPanel();\n    var nearestPanel = viewport.getNearestPanel();\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      e.stop();\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    var destInfo = overThreshold ? moveType.findTargetPanel(moveTypeContext) : moveType.findRestorePanel(moveTypeContext);\n    viewport.moveTo(destInfo.panel, destInfo.destPos, destInfo.eventType, e, destInfo.duration).onSuccess(function () {\n      transitTo(STATE_TYPE.ANIMATING);\n    }).onStopped(function () {\n      transitTo(STATE_TYPE.DISABLED);\n      stopCamera(e);\n    });\n  };\n\n  return DraggingState;\n}(State);\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar AnimatingState = /*#__PURE__*/function (_super) {\n  __extends(AnimatingState, _super);\n\n  function AnimatingState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = STATE_TYPE.ANIMATING;\n    _this.holding = false;\n    _this.playing = true;\n    return _this;\n  }\n\n  var __proto = AnimatingState.prototype;\n\n  __proto.onHold = function (e, _a) {\n    var viewport = _a.viewport,\n        triggerEvent = _a.triggerEvent,\n        transitTo = _a.transitTo;\n    var options = viewport.options;\n    var scrollArea = viewport.getScrollArea();\n    var scrollAreaSize = viewport.getScrollAreaSize();\n    var loopCount = Math.floor((this.lastPosition + this.delta - scrollArea.prev) / scrollAreaSize);\n    var targetPanel = this.targetPanel;\n\n    if (options.circular && loopCount !== 0 && targetPanel) {\n      var cloneCount = viewport.panelManager.getCloneCount();\n      var originalTargetPosition = targetPanel.getPosition(); // cloneIndex is from -1 to cloneCount - 1\n\n      var newCloneIndex = circulate(targetPanel.getCloneIndex() - loopCount, -1, cloneCount - 1, true);\n      var newTargetPosition = originalTargetPosition - loopCount * scrollAreaSize;\n      var newTargetPanel = targetPanel.getIdenticalPanels()[newCloneIndex + 1].clone(newCloneIndex, true); // Set new target panel considering looped count\n\n      newTargetPanel.setPosition(newTargetPosition);\n      this.targetPanel = newTargetPanel;\n    } // Reset last position and delta\n\n\n    this.delta = 0;\n    this.lastPosition = viewport.getCameraPosition(); // Update current panel as current nearest panel\n\n    viewport.setCurrentPanel(viewport.getNearestPanel());\n    triggerEvent(EVENTS.HOLD_START, e, true).onSuccess(function () {\n      transitTo(STATE_TYPE.DRAGGING);\n    }).onStopped(function () {\n      transitTo(STATE_TYPE.DISABLED);\n    });\n  };\n\n  __proto.onChange = function (e, _a) {\n    var moveCamera = _a.moveCamera,\n        transitTo = _a.transitTo;\n\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e).onStopped(function () {\n      transitTo(STATE_TYPE.DISABLED);\n    });\n  };\n\n  __proto.onFinish = function (e, _a) {\n    var flicking = _a.flicking,\n        viewport = _a.viewport,\n        triggerEvent = _a.triggerEvent,\n        transitTo = _a.transitTo;\n    var isTrusted = e && e.isTrusted;\n    viewport.options.bound ? viewport.setCurrentPanel(this.targetPanel) : viewport.setCurrentPanel(viewport.getNearestPanel());\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n\n    transitTo(STATE_TYPE.IDLE);\n    viewport.updateCameraPosition();\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted, {\n      direction: this.direction\n    });\n  };\n\n  return AnimatingState;\n}(State);\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar DisabledState = /*#__PURE__*/function (_super) {\n  __extends(DisabledState, _super);\n\n  function DisabledState() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = STATE_TYPE.DISABLED;\n    _this.holding = false;\n    _this.playing = true;\n    return _this;\n  }\n\n  var __proto = DisabledState.prototype;\n\n  __proto.onAnimationEnd = function (e, _a) {\n    var transitTo = _a.transitTo;\n    transitTo(STATE_TYPE.IDLE);\n  };\n\n  __proto.onChange = function (e, _a) {\n    var viewport = _a.viewport,\n        transitTo = _a.transitTo; // Can stop Axes's change event\n\n    e.stop(); // Should update axes position as it's already changed at this moment\n\n    viewport.updateAxesPosition(viewport.getCameraPosition());\n    transitTo(STATE_TYPE.IDLE);\n  };\n\n  __proto.onRelease = function (e, _a) {\n    var transitTo = _a.transitTo; // This is needed when stopped hold start event\n\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  };\n\n  return DisabledState;\n}(State);\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar StateMachine = /*#__PURE__*/function () {\n  function StateMachine() {\n    var _this = this;\n\n    this.state = new IdleState();\n\n    this.transitTo = function (nextStateType) {\n      var currentState = _this.state;\n\n      if (currentState.type !== nextStateType) {\n        var nextState = void 0;\n\n        switch (nextStateType) {\n          case STATE_TYPE.IDLE:\n            nextState = new IdleState();\n            break;\n\n          case STATE_TYPE.HOLDING:\n            nextState = new HoldingState();\n            break;\n\n          case STATE_TYPE.DRAGGING:\n            nextState = new DraggingState();\n            break;\n\n          case STATE_TYPE.ANIMATING:\n            nextState = new AnimatingState();\n            break;\n\n          case STATE_TYPE.DISABLED:\n            nextState = new DisabledState();\n            break;\n        }\n\n        currentState.onExit(nextState);\n        nextState.onEnter(currentState);\n        _this.state = nextState;\n      }\n\n      return _this.state;\n    };\n  }\n\n  var __proto = StateMachine.prototype;\n\n  __proto.fire = function (eventType, e, context) {\n    var currentState = this.state;\n\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  };\n\n  __proto.getState = function () {\n    return this.state;\n  };\n\n  return StateMachine;\n}();\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar MoveType = /*#__PURE__*/function () {\n  function MoveType() {}\n\n  var __proto = MoveType.prototype;\n\n  __proto.is = function (type) {\n    return type === this.type;\n  };\n\n  __proto.findRestorePanel = function (ctx) {\n    var viewport = ctx.viewport;\n    var options = viewport.options;\n    var panel = options.circular ? this.findRestorePanelInCircularMode(ctx) : viewport.getCurrentPanel();\n    return {\n      panel: panel,\n      destPos: viewport.findEstimatedPosition(panel),\n      duration: options.duration,\n      eventType: EVENTS.RESTORE\n    };\n  };\n\n  __proto.findPanelWhenInterrupted = function (ctx) {\n    var state = ctx.state,\n        viewport = ctx.viewport;\n    var targetPanel = state.targetPanel;\n    return {\n      panel: targetPanel,\n      destPos: viewport.findEstimatedPosition(targetPanel),\n      duration: viewport.options.duration,\n      eventType: \"\"\n    };\n  }; // Calculate minimum distance to \"change\" panel\n\n\n  __proto.calcBrinkOfChange = function (ctx) {\n    var viewport = ctx.viewport,\n        isNextDirection = ctx.isNextDirection;\n    var options = viewport.options;\n    var currentPanel = viewport.getCurrentPanel();\n    var halfGap = options.gap / 2;\n    var relativeAnchorPosition = currentPanel.getRelativeAnchorPosition(); // Minimum distance needed to decide prev/next panel as nearest\n\n    /*\r\n     * |  Prev  |     Next     |\r\n     * |--------|--------------|\r\n     * [][      |<-Anchor    ][] <- Panel + Half-Gap\r\n     */\n\n    var minimumDistanceToChange = isNextDirection ? currentPanel.getSize() - relativeAnchorPosition + halfGap : relativeAnchorPosition + halfGap;\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n    return minimumDistanceToChange;\n  };\n\n  __proto.findRestorePanelInCircularMode = function (ctx) {\n    var viewport = ctx.viewport;\n    var originalPanel = viewport.getCurrentPanel().getOriginalPanel();\n    var hangerPosition = viewport.getHangerPosition();\n    var firstClonedPanel = originalPanel.getIdenticalPanels()[1];\n    var lapped = Math.abs(originalPanel.getAnchorPosition() - hangerPosition) > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n    return !ctx.isNextDirection && lapped ? firstClonedPanel : originalPanel;\n  };\n\n  return MoveType;\n}();\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar Snap = /*#__PURE__*/function (_super) {\n  __extends(Snap, _super);\n\n  function Snap(count) {\n    var _this = _super.call(this) || this;\n\n    _this.type = MOVE_TYPE.SNAP;\n    _this.count = count;\n    return _this;\n  }\n\n  var __proto = Snap.prototype;\n\n  __proto.findTargetPanel = function (ctx) {\n    var viewport = ctx.viewport,\n        axesEvent = ctx.axesEvent,\n        swipeDistance = ctx.swipeDistance;\n    var snapCount = this.count;\n    var eventDelta = Math.abs(axesEvent.delta.flick);\n    var currentPanel = viewport.getCurrentPanel();\n    var nearestPanel = viewport.getNearestPanel();\n    var minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n    var nearestIsCurrent = nearestPanel.getIndex() === currentPanel.getIndex(); // This can happen when bounce is 0\n\n    var shouldMoveWhenBounceIs0 = viewport.canSetBoundMode() && nearestIsCurrent;\n    var shouldMoveToAdjacent = !viewport.isOutOfBound() && (swipeDistance <= minimumDistanceToChange || shouldMoveWhenBounceIs0);\n\n    if (snapCount > 1 && eventDelta > minimumDistanceToChange) {\n      return this.findSnappedPanel(ctx);\n    } else if (shouldMoveToAdjacent) {\n      return this.findAdjacentPanel(ctx);\n    } else {\n      return {\n        panel: nearestPanel,\n        duration: viewport.options.duration,\n        destPos: viewport.findEstimatedPosition(nearestPanel),\n        // As swipeDistance holds mouse/touch position change regardless of bounce option value\n        // swipDistance > minimumDistanceToChange can happen in bounce area\n        // Second condition is for handling that.\n        eventType: swipeDistance <= minimumDistanceToChange || viewport.isOutOfBound() && nearestIsCurrent ? EVENTS.RESTORE : EVENTS.CHANGE\n      };\n    }\n  };\n\n  __proto.findSnappedPanel = function (ctx) {\n    var axesEvent = ctx.axesEvent,\n        viewport = ctx.viewport,\n        state = ctx.state,\n        isNextDirection = ctx.isNextDirection;\n    var eventDelta = Math.abs(axesEvent.delta.flick);\n    var minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n    var snapCount = this.count;\n    var options = viewport.options;\n    var scrollAreaSize = viewport.getScrollAreaSize();\n    var halfGap = options.gap / 2;\n    var estimatedHangerPos = axesEvent.destPos.flick + viewport.getRelativeHangerPosition();\n    var panelToMove = viewport.getNearestPanel();\n    var cycleIndex = panelToMove.getCloneIndex() + 1; // 0(original) or 1(clone)\n\n    var passedPanelCount = 0;\n\n    while (passedPanelCount < snapCount) {\n      // Since panelToMove holds also cloned panels, we should use original panel's position\n      var originalPanel = panelToMove.getOriginalPanel();\n      var panelPosition = originalPanel.getPosition() + cycleIndex * scrollAreaSize;\n      var panelSize = originalPanel.getSize();\n      var panelNextPosition = panelPosition + panelSize + halfGap;\n      var panelPrevPosition = panelPosition - halfGap; // Current panelToMove contains destPos\n\n      if (isNextDirection && panelNextPosition > estimatedHangerPos || !isNextDirection && panelPrevPosition < estimatedHangerPos) {\n        break;\n      }\n\n      var siblingPanel = isNextDirection ? panelToMove.nextSibling : panelToMove.prevSibling;\n\n      if (!siblingPanel) {\n        break;\n      }\n\n      var panelIndex = panelToMove.getIndex();\n      var siblingIndex = siblingPanel.getIndex();\n\n      if (isNextDirection && siblingIndex <= panelIndex || !isNextDirection && siblingIndex >= panelIndex) {\n        cycleIndex = isNextDirection ? cycleIndex + 1 : cycleIndex - 1;\n      }\n\n      panelToMove = siblingPanel;\n      passedPanelCount += 1;\n    }\n\n    var originalPosition = panelToMove.getOriginalPanel().getPosition();\n\n    if (cycleIndex !== 0) {\n      panelToMove = panelToMove.clone(panelToMove.getCloneIndex(), true);\n      panelToMove.setPosition(originalPosition + cycleIndex * scrollAreaSize);\n    }\n\n    var defaultDuration = viewport.options.duration;\n    var duration = clamp(axesEvent.duration, defaultDuration, defaultDuration * passedPanelCount);\n    return {\n      panel: panelToMove,\n      destPos: viewport.findEstimatedPosition(panelToMove),\n      duration: duration,\n      eventType: Math.max(eventDelta, state.delta) > minimumDistanceToChange ? EVENTS.CHANGE : EVENTS.RESTORE\n    };\n  };\n\n  __proto.findAdjacentPanel = function (ctx) {\n    var viewport = ctx.viewport,\n        isNextDirection = ctx.isNextDirection;\n    var options = viewport.options;\n    var currentIndex = viewport.getCurrentIndex();\n    var currentPanel = viewport.panelManager.get(currentIndex);\n    var hangerPosition = viewport.getHangerPosition();\n    var scrollArea = viewport.getScrollArea();\n    var firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    var lapped = options.circular && Math.abs(currentPanel.getAnchorPosition() - hangerPosition) > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition); // If lapped in circular mode, use first cloned panel as base panel\n\n    var basePanel = lapped ? firstClonedPanel : currentPanel;\n    var basePosition = basePanel.getPosition();\n    var adjacentPanel = isNextDirection ? basePanel.nextSibling : basePanel.prevSibling;\n    var eventType = adjacentPanel ? EVENTS.CHANGE : EVENTS.RESTORE;\n    var panelToMove = adjacentPanel ? adjacentPanel : basePanel;\n    var targetRelativeAnchorPosition = panelToMove.getRelativeAnchorPosition();\n    var estimatedPanelPosition = options.circular ? isNextDirection ? basePosition + basePanel.getSize() + targetRelativeAnchorPosition + options.gap : basePosition - (panelToMove.getSize() - targetRelativeAnchorPosition) - options.gap : panelToMove.getAnchorPosition();\n    var estimatedPosition = estimatedPanelPosition - viewport.getRelativeHangerPosition();\n    var destPos = viewport.canSetBoundMode() ? clamp(estimatedPosition, scrollArea.prev, scrollArea.next) : estimatedPosition;\n    return {\n      panel: panelToMove,\n      destPos: destPos,\n      duration: options.duration,\n      eventType: eventType\n    };\n  };\n\n  return Snap;\n}(MoveType);\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar FreeScroll = /*#__PURE__*/function (_super) {\n  __extends(FreeScroll, _super);\n\n  function FreeScroll() {\n    var _this = // Set snap count to Infinity\n    _super.call(this, Infinity) || this;\n\n    _this.type = MOVE_TYPE.FREE_SCROLL;\n    return _this;\n  }\n\n  var __proto = FreeScroll.prototype;\n\n  __proto.findTargetPanel = function (ctx) {\n    var axesEvent = ctx.axesEvent,\n        state = ctx.state,\n        viewport = ctx.viewport;\n    var destPos = axesEvent.destPos.flick;\n    var minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n    var scrollArea = viewport.getScrollArea();\n    var currentPanel = viewport.getCurrentPanel();\n    var options = viewport.options;\n    var delta = Math.abs(axesEvent.delta.flick + state.delta);\n\n    if (delta > minimumDistanceToChange) {\n      var destInfo = _super.prototype.findSnappedPanel.call(this, ctx);\n\n      destInfo.duration = axesEvent.duration;\n      destInfo.destPos = destPos;\n      destInfo.eventType = !options.circular && destInfo.panel === currentPanel ? \"\" : EVENTS.CHANGE;\n      return destInfo;\n    } else {\n      var estimatedPosition = options.circular ? circulate(destPos, scrollArea.prev, scrollArea.next, false) : destPos;\n      estimatedPosition = clamp(estimatedPosition, scrollArea.prev, scrollArea.next);\n      estimatedPosition += viewport.getRelativeHangerPosition();\n      var estimatedPanel = viewport.findNearestPanelAt(estimatedPosition);\n      return {\n        panel: estimatedPanel,\n        destPos: destPos,\n        duration: axesEvent.duration,\n        eventType: \"\"\n      };\n    }\n  };\n\n  __proto.findRestorePanel = function (ctx) {\n    return this.findTargetPanel(ctx);\n  };\n\n  __proto.findPanelWhenInterrupted = function (ctx) {\n    var viewport = ctx.viewport;\n    return {\n      panel: viewport.getNearestPanel(),\n      destPos: viewport.getCameraPosition(),\n      duration: 0,\n      eventType: \"\"\n    };\n  };\n\n  __proto.calcBrinkOfChange = function (ctx) {\n    var viewport = ctx.viewport,\n        isNextDirection = ctx.isNextDirection;\n    var options = viewport.options;\n    var currentPanel = viewport.getCurrentPanel();\n    var halfGap = options.gap / 2;\n    var lastPosition = viewport.stateMachine.getState().lastPosition;\n    var currentPanelPosition = currentPanel.getPosition(); // As camera can stop anywhere in free scroll mode,\n    // minimumDistanceToChange should be calculated differently.\n    // Ref #191(https://github.com/naver/egjs-flicking/issues/191)\n\n    var lastHangerPosition = lastPosition + viewport.getRelativeHangerPosition();\n    var scrollAreaSize = viewport.getScrollAreaSize();\n    var minimumDistanceToChange = isNextDirection ? currentPanelPosition + currentPanel.getSize() - lastHangerPosition + halfGap : lastHangerPosition - currentPanelPosition + halfGap;\n    minimumDistanceToChange = Math.abs(minimumDistanceToChange % scrollAreaSize);\n    return Math.min(minimumDistanceToChange, scrollAreaSize - minimumDistanceToChange);\n  };\n\n  return FreeScroll;\n}(Snap);\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nvar Viewport = /*#__PURE__*/function () {\n  function Viewport(flicking, options, triggerEvent) {\n    var _this = this;\n\n    this.plugins = [];\n\n    this.stopCamera = function (axesEvent) {\n      if (axesEvent && axesEvent.setTo) {\n        axesEvent.setTo({\n          flick: _this.state.position\n        }, 0);\n      }\n\n      _this.stateMachine.transitTo(STATE_TYPE.IDLE);\n    };\n\n    this.flicking = flicking;\n    this.triggerEvent = triggerEvent;\n    this.state = {\n      size: 0,\n      position: 0,\n      panelMaintainRatio: 0,\n      relativeHangerPosition: 0,\n      positionOffset: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0\n      },\n      translate: TRANSFORM,\n      infiniteThreshold: 0,\n      checkedIndexes: [],\n      isAdaptiveCached: false,\n      isViewportGiven: false,\n      isCameraGiven: false,\n      originalViewportStyle: {\n        className: null,\n        style: null\n      },\n      originalCameraStyle: {\n        className: null,\n        style: null\n      },\n      cachedBbox: null\n    };\n    this.options = options;\n    this.stateMachine = new StateMachine();\n    this.visiblePanels = [];\n    this.panelBboxes = {};\n    this.build();\n  }\n\n  var __proto = Viewport.prototype;\n\n  __proto.moveTo = function (panel, destPos, eventType, axesEvent, duration) {\n    var _this = this;\n\n    if (duration === void 0) {\n      duration = this.options.duration;\n    }\n\n    var state = this.state;\n    var currentState = this.stateMachine.getState();\n    var currentPosition = state.position;\n    var isTrusted = axesEvent ? axesEvent.isTrusted : false;\n    var direction = destPos === currentPosition ? null : destPos > currentPosition ? DIRECTION.NEXT : DIRECTION.PREV;\n    var eventResult;\n\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.getIndex(),\n        panel: panel,\n        direction: direction\n      });\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess: function onSuccess(callback) {\n          callback();\n          return this;\n        },\n        onStopped: function onStopped() {\n          return this;\n        }\n      };\n    }\n\n    eventResult.onSuccess(function () {\n      currentState.delta = 0;\n      currentState.lastPosition = _this.getCameraPosition();\n      currentState.targetPanel = panel;\n      currentState.direction = destPos === currentPosition ? null : destPos > currentPosition ? DIRECTION.NEXT : DIRECTION.PREV;\n\n      if (destPos === currentPosition) {\n        // no move\n        _this.nearestPanel = panel;\n        _this.currentPanel = panel;\n      }\n\n      if (axesEvent && axesEvent.setTo) {\n        // freeScroll only occurs in release events\n        axesEvent.setTo({\n          flick: destPos\n        }, duration);\n      } else {\n        _this.axes.setTo({\n          flick: destPos\n        }, duration);\n      }\n    });\n    return eventResult;\n  };\n\n  __proto.moveCamera = function (pos, axesEvent) {\n    var state = this.state;\n    var options = this.options;\n    var transform = state.translate.name;\n    var scrollArea = state.scrollArea; // Update position & nearestPanel\n\n    if (options.circular && !isBetween(pos, scrollArea.prev, scrollArea.next)) {\n      pos = circulate(pos, scrollArea.prev, scrollArea.next, false);\n    }\n\n    state.position = pos;\n    this.nearestPanel = this.findNearestPanel();\n    var nearestPanel = this.nearestPanel;\n    var originalNearestPosition = nearestPanel ? nearestPanel.getPosition() : 0; // From 0(panel position) to 1(panel position + panel size)\n    // When it's on gap area value will be (val > 1 || val < 0)\n\n    if (nearestPanel) {\n      var hangerPosition = this.getHangerPosition();\n      var panelPosition = nearestPanel.getPosition();\n      var panelSize = nearestPanel.getSize();\n      var halfGap = options.gap / 2; // As panel's range is from panel position - half gap ~ panel pos + panel size + half gap\n\n      state.panelMaintainRatio = (hangerPosition - panelPosition + halfGap) / (panelSize + 2 * halfGap);\n    } else {\n      state.panelMaintainRatio = 0;\n    }\n\n    this.checkNeedPanel(axesEvent); // Possibly modified after need panel, if it's looped\n\n    var modifiedNearestPosition = nearestPanel ? nearestPanel.getPosition() : 0;\n    pos += modifiedNearestPosition - originalNearestPosition;\n    state.position = pos;\n    this.updateVisiblePanels(); // Offset is needed to fix camera layer size in visible-only rendering mode\n\n    var posOffset = options.renderOnlyVisible ? state.positionOffset : 0;\n    var moveVector = options.horizontal ? [-(pos - posOffset), 0] : [0, -(pos - posOffset)];\n    var moveCoord = moveVector.map(function (coord) {\n      return Math.round(coord) + \"px\";\n    }).join(\", \");\n    this.cameraElement.style[transform] = state.translate.has3d ? \"translate3d(\" + moveCoord + \", 0px)\" : \"translate(\" + moveCoord + \")\";\n  };\n\n  __proto.unCacheBbox = function () {\n    var state = this.state;\n    var options = this.options;\n    state.cachedBbox = null;\n    this.visiblePanels = [];\n    var viewportElement = this.viewportElement;\n\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n    } else {\n      viewportElement.style.height = \"\";\n    }\n\n    state.isAdaptiveCached = false;\n    this.panelBboxes = {};\n  };\n\n  __proto.resize = function () {\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n    this.updateClonePanels();\n    this.updateCameraPosition();\n    this.updatePlugins();\n  }; // Find nearest anchor from current hanger position\n\n\n  __proto.findNearestPanel = function () {\n    var state = this.state;\n    var panelManager = this.panelManager;\n    var hangerPosition = this.getHangerPosition();\n\n    if (this.isOutOfBound()) {\n      var position = state.position;\n      return position <= state.scrollArea.prev ? panelManager.firstPanel() : panelManager.lastPanel();\n    }\n\n    return this.findNearestPanelAt(hangerPosition);\n  };\n\n  __proto.findNearestPanelAt = function (position) {\n    var panelManager = this.panelManager;\n    var allPanels = panelManager.allPanels();\n    var minimumDistance = Infinity;\n    var nearestPanel;\n\n    for (var _i = 0, allPanels_1 = allPanels; _i < allPanels_1.length; _i++) {\n      var panel = allPanels_1[_i];\n\n      if (!panel) {\n        continue;\n      }\n\n      var prevPosition = panel.getPosition();\n      var nextPosition = prevPosition + panel.getSize(); // Use shortest distance from panel's range\n\n      var distance = isBetween(position, prevPosition, nextPosition) ? 0 : Math.min(Math.abs(prevPosition - position), Math.abs(nextPosition - position));\n\n      if (distance > minimumDistance) {\n        break;\n      } else if (distance === minimumDistance) {\n        var minimumAnchorDistance = Math.abs(position - nearestPanel.getAnchorPosition());\n        var anchorDistance = Math.abs(position - panel.getAnchorPosition());\n\n        if (anchorDistance > minimumAnchorDistance) {\n          break;\n        }\n      }\n\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel;\n  };\n\n  __proto.findNearestIdenticalPanel = function (panel) {\n    var nearest = panel;\n    var shortestDistance = Infinity;\n    var hangerPosition = this.getHangerPosition();\n    var identicals = panel.getIdenticalPanels();\n    identicals.forEach(function (identical) {\n      var anchorPosition = identical.getAnchorPosition();\n      var distance = Math.abs(anchorPosition - hangerPosition);\n\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n    return nearest;\n  }; // Find shortest camera position that distance is minimum\n\n\n  __proto.findShortestPositionToPanel = function (panel) {\n    var state = this.state;\n    var options = this.options;\n    var anchorPosition = panel.getAnchorPosition();\n    var hangerPosition = this.getHangerPosition();\n    var distance = Math.abs(hangerPosition - anchorPosition);\n    var scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      var position = anchorPosition - state.relativeHangerPosition;\n      return this.canSetBoundMode() ? clamp(position, state.scrollArea.prev, state.scrollArea.next) : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance ? anchorPosition - state.relativeHangerPosition : anchorPosition > hangerPosition // PREV TO NEXT\n      ? anchorPosition - state.relativeHangerPosition - scrollAreaSize // NEXT TO PREV\n      : anchorPosition - state.relativeHangerPosition + scrollAreaSize;\n    }\n  };\n\n  __proto.findEstimatedPosition = function (panel) {\n    var scrollArea = this.getScrollArea();\n    var estimatedPosition = panel.getAnchorPosition() - this.getRelativeHangerPosition();\n    estimatedPosition = this.canSetBoundMode() ? clamp(estimatedPosition, scrollArea.prev, scrollArea.next) : estimatedPosition;\n    return estimatedPosition;\n  };\n\n  __proto.addVisiblePanel = function (panel) {\n    if (this.getVisibleIndexOf(panel) < 0) {\n      this.visiblePanels.push(panel);\n    }\n  };\n\n  __proto.enable = function () {\n    this.panInput.enable();\n  };\n\n  __proto.disable = function () {\n    this.panInput.disable();\n  };\n\n  __proto.insert = function (index, element) {\n    var _this = this;\n\n    var lastIndex = this.panelManager.getLastIndex(); // Index should not below 0\n\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    var state = this.state;\n    var options = this.options;\n    var parsedElements = parseElement(element);\n    var panels = parsedElements.map(function (el, idx) {\n      return new Panel(el, index + idx, _this);\n    }).slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    var pushedIndex = this.panelManager.insert(index, panels); // ...then calc bbox for all panels\n\n    this.resizePanels(panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n      this.nearestPanel = panels[0];\n      var newCenterPanel = panels[0];\n      var newPanelPosition = this.findEstimatedPosition(newCenterPanel);\n      state.position = newPanelPosition;\n      this.updateAxesPosition(newPanelPosition);\n      state.panelMaintainRatio = (newCenterPanel.getRelativeAnchorPosition() + options.gap / 2) / (newCenterPanel.getSize() + options.gap);\n    } // Update checked indexes in infinite mode\n\n\n    this.updateCheckedIndexes({\n      min: index,\n      max: index\n    });\n    state.checkedIndexes.forEach(function (indexes, idx) {\n      var min = indexes[0],\n          max = indexes[1];\n\n      if (index < min) {\n        // Push checked index\n        state.checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n      }\n    });\n    this.resize();\n    return panels;\n  };\n\n  __proto.replace = function (index, element) {\n    var _this = this;\n\n    var state = this.state;\n    var options = this.options;\n    var panelManager = this.panelManager;\n    var lastIndex = panelManager.getLastIndex(); // Index should not below 0\n\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    var parsedElements = parseElement(element);\n    var panels = parsedElements.map(function (el, idx) {\n      return new Panel(el, index + idx, _this);\n    }).slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    var replacedPanels = panelManager.replace(index, panels);\n    replacedPanels.forEach(function (panel) {\n      var visibleIndex = _this.getVisibleIndexOf(panel);\n\n      if (visibleIndex > -1) {\n        _this.visiblePanels.splice(visibleIndex, 1);\n      }\n    }); // ...then calc bbox for all panels\n\n    this.resizePanels(panels);\n    var currentPanel = this.currentPanel;\n    var wasEmpty = !currentPanel;\n\n    if (wasEmpty) {\n      this.currentPanel = panels[0];\n      this.nearestPanel = panels[0];\n      var newCenterPanel = panels[0];\n      var newPanelPosition = this.findEstimatedPosition(newCenterPanel);\n      state.position = newPanelPosition;\n      this.updateAxesPosition(newPanelPosition);\n      state.panelMaintainRatio = (newCenterPanel.getRelativeAnchorPosition() + options.gap / 2) / (newCenterPanel.getSize() + options.gap);\n    } else if (isBetween(currentPanel.getIndex(), index, index + panels.length - 1)) {\n      // Current panel is replaced\n      this.currentPanel = panelManager.get(currentPanel.getIndex());\n    } // Update checked indexes in infinite mode\n\n\n    this.updateCheckedIndexes({\n      min: index,\n      max: index + panels.length - 1\n    });\n    this.resize();\n    return panels;\n  };\n\n  __proto.remove = function (index, deleteCount) {\n    if (deleteCount === void 0) {\n      deleteCount = 1;\n    }\n\n    var state = this.state; // Index should not below 0\n\n    index = Math.max(index, 0);\n    var panelManager = this.panelManager;\n    var currentIndex = this.getCurrentIndex();\n    var removedPanels = panelManager.remove(index, deleteCount);\n\n    if (isBetween(currentIndex, index, index + deleteCount - 1)) {\n      // Current panel is removed\n      // Use panel at removing index - 1 as new current panel if it exists\n      var newCurrentIndex = Math.max(index - 1, panelManager.getRange().min);\n      this.currentPanel = panelManager.get(newCurrentIndex);\n    } // Update checked indexes in infinite mode\n\n\n    if (deleteCount > 0) {\n      // Check whether removing index will affect checked indexes\n      // Suppose index 0 is empty and removed index 1, then checked index 0 should be deleted and vice versa.\n      this.updateCheckedIndexes({\n        min: index - 1,\n        max: index + deleteCount\n      }); // Uncache visible panels to refresh panels\n\n      this.visiblePanels = [];\n    }\n\n    if (panelManager.getPanelCount() <= 0) {\n      this.currentPanel = undefined;\n      this.nearestPanel = undefined;\n    }\n\n    this.resize();\n    var scrollArea = state.scrollArea;\n\n    if (state.position < scrollArea.prev || state.position > scrollArea.next) {\n      var newPosition = circulate(state.position, scrollArea.prev, scrollArea.next, false);\n      this.moveCamera(newPosition);\n      this.updateAxesPosition(newPosition);\n    }\n\n    return removedPanels;\n  };\n\n  __proto.updateAdaptiveSize = function () {\n    var state = this.state;\n    var options = this.options;\n    var horizontal = options.horizontal;\n    var currentPanel = this.getCurrentPanel();\n\n    if (!currentPanel) {\n      return;\n    }\n\n    var shouldApplyAdaptive = options.adaptive || !state.isAdaptiveCached;\n    var viewportStyle = this.viewportElement.style;\n\n    if (shouldApplyAdaptive) {\n      var sizeToApply = void 0;\n\n      if (options.adaptive) {\n        var panelBbox = currentPanel.getBbox();\n        sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n      } else {\n        // Find minimum height of panels to maximum panel size\n        var maximumPanelSize = this.panelManager.originalPanels().reduce(function (maximum, panel) {\n          var panelBbox = panel.getBbox();\n          return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n        }, 0);\n        sizeToApply = maximumPanelSize;\n      }\n\n      if (!state.isAdaptiveCached) {\n        var viewportBbox = this.updateBbox();\n        sizeToApply = Math.max(sizeToApply, horizontal ? viewportBbox.height : viewportBbox.width);\n        state.isAdaptiveCached = true;\n      }\n\n      var viewportSize = sizeToApply + \"px\";\n\n      if (horizontal) {\n        viewportStyle.height = viewportSize;\n        state.cachedBbox.height = sizeToApply;\n      } else {\n        viewportStyle.width = viewportSize;\n        state.cachedBbox.width = sizeToApply;\n      }\n    }\n  }; // Update camera position after resizing\n\n\n  __proto.updateCameraPosition = function () {\n    var state = this.state;\n    var currentPanel = this.getCurrentPanel();\n    var currentState = this.stateMachine.getState();\n    var isFreeScroll = this.moveType.is(MOVE_TYPE.FREE_SCROLL);\n    var relativeHangerPosition = this.getRelativeHangerPosition();\n    var halfGap = this.options.gap / 2;\n\n    if (currentState.holding || currentState.playing) {\n      this.updateVisiblePanels();\n      return;\n    }\n\n    var newPosition;\n\n    if (isFreeScroll) {\n      var nearestPanel = this.getNearestPanel();\n      newPosition = nearestPanel ? nearestPanel.getPosition() - halfGap + (nearestPanel.getSize() + 2 * halfGap) * state.panelMaintainRatio - relativeHangerPosition : this.getCameraPosition();\n    } else {\n      newPosition = currentPanel ? currentPanel.getAnchorPosition() - relativeHangerPosition : this.getCameraPosition();\n    }\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    } // Pause & resume axes to prevent axes's \"change\" event triggered\n    // This should be done before moveCamera, as moveCamera can trigger needPanel\n\n\n    this.updateAxesPosition(newPosition);\n    this.moveCamera(newPosition);\n  };\n\n  __proto.updateBbox = function () {\n    var state = this.state;\n    var options = this.options;\n    var viewportElement = this.viewportElement;\n\n    if (!state.cachedBbox) {\n      state.cachedBbox = getBbox(viewportElement, options.useOffset);\n    }\n\n    return state.cachedBbox;\n  };\n\n  __proto.updatePlugins = function () {\n    var _this = this; // update for resize\n\n\n    this.plugins.forEach(function (plugin) {\n      plugin.update && plugin.update(_this.flicking);\n    });\n  };\n\n  __proto.destroy = function (option) {\n    var state = this.state;\n    var wrapper = this.flicking.getElement();\n    var viewportElement = this.viewportElement;\n    var cameraElement = this.cameraElement;\n    var originalPanels = this.panelManager.originalPanels();\n    this.removePlugins(this.plugins);\n\n    if (!option.preserveUI) {\n      restoreStyle(viewportElement, state.originalViewportStyle);\n      restoreStyle(cameraElement, state.originalCameraStyle);\n\n      if (!state.isCameraGiven && !this.options.renderExternal) {\n        var topmostElement_1 = state.isViewportGiven ? viewportElement : wrapper;\n        var deletingElement = state.isViewportGiven ? cameraElement : viewportElement;\n        originalPanels.forEach(function (panel) {\n          topmostElement_1.appendChild(panel.getElement());\n        });\n        topmostElement_1.removeChild(deletingElement);\n      }\n    }\n\n    this.axes.destroy();\n    this.panInput.destroy();\n    originalPanels.forEach(function (panel) {\n      panel.destroy(option);\n    }); // release resources\n\n    for (var x in this) {\n      this[x] = null;\n    }\n  };\n\n  __proto.restore = function (status) {\n    var panels = status.panels;\n    var defaultIndex = this.options.defaultIndex;\n    var cameraElement = this.cameraElement;\n    var panelManager = this.panelManager; // Restore index\n\n    cameraElement.innerHTML = panels.map(function (panel) {\n      return panel.html;\n    }).join(\"\"); // Create panels first\n\n    this.refreshPanels();\n    var createdPanels = panelManager.originalPanels(); // ...then order it by its index\n\n    var orderedPanels = [];\n    panels.forEach(function (panel, idx) {\n      var createdPanel = createdPanels[idx];\n      createdPanel.setIndex(panel.index);\n      orderedPanels[panel.index] = createdPanel;\n    });\n    panelManager.replacePanels(orderedPanels, []);\n    panelManager.setCloneCount(0); // No clones at this point\n\n    var panelCount = panelManager.getPanelCount();\n\n    if (panelCount > 0) {\n      this.currentPanel = panelManager.get(status.index) || panelManager.get(defaultIndex) || panelManager.firstPanel();\n      this.nearestPanel = this.currentPanel;\n    } else {\n      this.currentPanel = undefined;\n      this.nearestPanel = undefined;\n    }\n\n    this.visiblePanels = orderedPanels.filter(function (panel) {\n      return Boolean(panel);\n    });\n    this.resize();\n    this.axes.setTo({\n      flick: status.position\n    }, 0);\n    this.moveCamera(status.position);\n  };\n\n  __proto.calcVisiblePanels = function () {\n    var allPanels = this.panelManager.allPanels();\n\n    if (this.options.renderOnlyVisible) {\n      var cameraPos_1 = this.getCameraPosition();\n      var viewportSize_1 = this.getSize();\n      var basePanel = this.nearestPanel;\n\n      var getNextPanel = function getNextPanel(panel) {\n        var nextPanel = panel.nextSibling;\n\n        if (nextPanel && nextPanel.getPosition() >= panel.getPosition()) {\n          return nextPanel;\n        } else {\n          return null;\n        }\n      };\n\n      var getPrevPanel = function getPrevPanel(panel) {\n        var prevPanel = panel.prevSibling;\n\n        if (prevPanel && prevPanel.getPosition() <= panel.getPosition()) {\n          return prevPanel;\n        } else {\n          return null;\n        }\n      };\n\n      var isOutOfBoundNext = function isOutOfBoundNext(panel) {\n        return panel.getPosition() >= cameraPos_1 + viewportSize_1;\n      };\n\n      var isOutOfBoundPrev = function isOutOfBoundPrev(panel) {\n        return panel.getPosition() + panel.getSize() <= cameraPos_1;\n      };\n\n      var getVisiblePanels = function getVisiblePanels(panel, getNext, isOutOfViewport) {\n        var visiblePanels = [];\n        var lastPanel = panel;\n\n        while (true) {\n          var nextPanel = getNext(lastPanel);\n\n          if (!nextPanel || isOutOfViewport(nextPanel)) {\n            break;\n          }\n\n          visiblePanels.push(nextPanel);\n          lastPanel = nextPanel;\n        }\n\n        return visiblePanels;\n      };\n\n      var panelCount_1 = this.panelManager.getPanelCount();\n\n      var getAbsIndex_1 = function getAbsIndex_1(panel) {\n        return panel.getIndex() + (panel.getCloneIndex() + 1) * panelCount_1;\n      };\n\n      var nextPanels = getVisiblePanels(basePanel, getNextPanel, isOutOfBoundNext);\n      var prevPanels = getVisiblePanels(basePanel, getPrevPanel, isOutOfBoundPrev);\n      return [basePanel].concat(nextPanels, prevPanels).sort(function (panel1, panel2) {\n        return getAbsIndex_1(panel1) - getAbsIndex_1(panel2);\n      });\n    } else {\n      return allPanels.filter(function (panel) {\n        var outsetProgress = panel.getOutsetProgress();\n        return outsetProgress > -1 && outsetProgress < 1;\n      });\n    }\n  };\n\n  __proto.getCurrentPanel = function () {\n    return this.currentPanel;\n  };\n\n  __proto.getCurrentIndex = function () {\n    var currentPanel = this.currentPanel;\n    return currentPanel ? currentPanel.getIndex() : -1;\n  };\n\n  __proto.getNearestPanel = function () {\n    return this.nearestPanel;\n  }; // Get progress from nearest panel\n\n\n  __proto.getCurrentProgress = function () {\n    var currentState = this.stateMachine.getState();\n    var nearestPanel = currentState.playing || currentState.holding ? this.nearestPanel : this.currentPanel;\n    var panelManager = this.panelManager;\n\n    if (!nearestPanel) {\n      // There're no panels\n      return NaN;\n    }\n\n    var _a = this.getScrollArea(),\n        prevRange = _a.prev,\n        nextRange = _a.next;\n\n    var cameraPosition = this.getCameraPosition();\n    var isOutOfBound = this.isOutOfBound();\n    var prevPanel = nearestPanel.prevSibling;\n    var nextPanel = nearestPanel.nextSibling;\n    var hangerPosition = this.getHangerPosition();\n    var nearestAnchorPos = nearestPanel.getAnchorPosition();\n\n    if (isOutOfBound && prevPanel && nextPanel && cameraPosition < nextRange // On the basis of anchor, prevPanel is nearestPanel.\n    && hangerPosition - prevPanel.getAnchorPosition() < nearestAnchorPos - hangerPosition) {\n      nearestPanel = prevPanel;\n      nextPanel = nearestPanel.nextSibling;\n      prevPanel = nearestPanel.prevSibling;\n      nearestAnchorPos = nearestPanel.getAnchorPosition();\n    }\n\n    var nearestIndex = nearestPanel.getIndex() + (nearestPanel.getCloneIndex() + 1) * panelManager.getPanelCount();\n    var nearestSize = nearestPanel.getSize();\n\n    if (isOutOfBound) {\n      var relativeHangerPosition = this.getRelativeHangerPosition();\n\n      if (nearestAnchorPos > nextRange + relativeHangerPosition) {\n        // next bounce area: hangerPosition - relativeHangerPosition - nextRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - nextRange;\n      } else if (nearestAnchorPos < prevRange + relativeHangerPosition) {\n        // prev bounce area: hangerPosition - relativeHangerPosition - prevRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - prevRange;\n      }\n    }\n\n    var hangerIsNextToNearestPanel = hangerPosition >= nearestAnchorPos;\n    var gap = this.options.gap;\n    var basePosition = nearestAnchorPos;\n    var targetPosition = nearestAnchorPos;\n\n    if (hangerIsNextToNearestPanel) {\n      targetPosition = nextPanel ? nextPanel.getAnchorPosition() : nearestAnchorPos + nearestSize + gap;\n    } else {\n      basePosition = prevPanel ? prevPanel.getAnchorPosition() : nearestAnchorPos - nearestSize - gap;\n    }\n\n    var progressBetween = (hangerPosition - basePosition) / (targetPosition - basePosition);\n    var startIndex = hangerIsNextToNearestPanel ? nearestIndex : prevPanel ? prevPanel.getIndex() : nearestIndex - 1;\n    return startIndex + progressBetween;\n  }; // Update axes flick position without triggering event\n\n\n  __proto.updateAxesPosition = function (position) {\n    var axes = this.axes;\n    axes.off();\n    axes.setTo({\n      flick: position\n    }, 0);\n    axes.on(this.axesHandlers);\n  };\n\n  __proto.getSize = function () {\n    return this.state.size;\n  };\n\n  __proto.getScrollArea = function () {\n    return this.state.scrollArea;\n  };\n\n  __proto.isOutOfBound = function () {\n    var state = this.state;\n    var options = this.options;\n    var scrollArea = state.scrollArea;\n    return !options.circular && options.bound && (state.position <= scrollArea.prev || state.position >= scrollArea.next);\n  };\n\n  __proto.canSetBoundMode = function () {\n    var options = this.options;\n    return options.bound && !options.circular;\n  };\n\n  __proto.getViewportElement = function () {\n    return this.viewportElement;\n  };\n\n  __proto.getCameraElement = function () {\n    return this.cameraElement;\n  };\n\n  __proto.getScrollAreaSize = function () {\n    var scrollArea = this.state.scrollArea;\n    return scrollArea.next - scrollArea.prev;\n  };\n\n  __proto.getRelativeHangerPosition = function () {\n    return this.state.relativeHangerPosition;\n  };\n\n  __proto.getHangerPosition = function () {\n    return this.state.position + this.state.relativeHangerPosition;\n  };\n\n  __proto.getCameraPosition = function () {\n    return this.state.position;\n  };\n\n  __proto.getPositionOffset = function () {\n    return this.state.positionOffset;\n  };\n\n  __proto.getCheckedIndexes = function () {\n    return this.state.checkedIndexes;\n  };\n\n  __proto.getVisiblePanels = function () {\n    return this.visiblePanels;\n  };\n\n  __proto.setCurrentPanel = function (panel) {\n    this.currentPanel = panel;\n  };\n\n  __proto.setLastIndex = function (index) {\n    var currentPanel = this.currentPanel;\n    var panelManager = this.panelManager;\n    panelManager.setLastIndex(index);\n\n    if (currentPanel && currentPanel.getIndex() > index) {\n      this.currentPanel = panelManager.lastPanel();\n    }\n\n    this.resize();\n  };\n\n  __proto.setVisiblePanels = function (panels) {\n    this.visiblePanels = panels;\n  };\n\n  __proto.connectAxesHandler = function (handlers) {\n    var axes = this.axes;\n    this.axesHandlers = handlers;\n    axes.on(handlers);\n  };\n\n  __proto.addPlugins = function (plugins) {\n    var _this = this;\n\n    var newPlugins = [].concat(plugins);\n    newPlugins.forEach(function (plugin) {\n      plugin.init(_this.flicking);\n    });\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  };\n\n  __proto.removePlugins = function (plugins) {\n    var _this = this;\n\n    var currentPlugins = this.plugins;\n    var removedPlugins = [].concat(plugins);\n    removedPlugins.forEach(function (plugin) {\n      var index = currentPlugins.indexOf(plugin);\n\n      if (index > -1) {\n        currentPlugins.splice(index, 1);\n      }\n\n      plugin.destroy(_this.flicking);\n    });\n    return this;\n  };\n\n  __proto.updateCheckedIndexes = function (changedRange) {\n    var state = this.state;\n    var removed = 0;\n    state.checkedIndexes.concat().forEach(function (indexes, idx) {\n      var min = indexes[0],\n          max = indexes[1]; // Can fill part of indexes in range\n\n      if (changedRange.min <= max && changedRange.max >= min) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx - removed, 1);\n        removed++;\n      }\n    });\n  };\n\n  __proto.appendUncachedPanelElements = function (panels) {\n    var _this = this;\n\n    var options = this.options;\n    var fragment = document.createDocumentFragment();\n\n    if (options.isEqualSize) {\n      var prevVisiblePanels = this.visiblePanels;\n      var equalSizeClasses_1 = options.isEqualSize; // for readability\n\n      var cached_1 = {};\n      this.visiblePanels = [];\n      Object.keys(this.panelBboxes).forEach(function (className) {\n        cached_1[className] = true;\n      });\n      panels.forEach(function (panel) {\n        var overlappedClass = panel.getOverlappedClass(equalSizeClasses_1);\n\n        if (overlappedClass && !cached_1[overlappedClass]) {\n          if (!options.renderExternal) {\n            fragment.appendChild(panel.getElement());\n          }\n\n          _this.visiblePanels.push(panel);\n\n          cached_1[overlappedClass] = true;\n        } else if (!overlappedClass) {\n          if (!options.renderExternal) {\n            fragment.appendChild(panel.getElement());\n          }\n\n          _this.visiblePanels.push(panel);\n        }\n      });\n      prevVisiblePanels.forEach(function (panel) {\n        _this.addVisiblePanel(panel);\n      });\n    } else {\n      if (!options.renderExternal) {\n        panels.forEach(function (panel) {\n          return fragment.appendChild(panel.getElement());\n        });\n      }\n\n      this.visiblePanels = panels.filter(function (panel) {\n        return Boolean(panel);\n      });\n    }\n\n    if (!options.renderExternal) {\n      this.cameraElement.appendChild(fragment);\n    }\n  };\n\n  __proto.updateClonePanels = function () {\n    var panelManager = this.panelManager; // Clone panels in circular mode\n\n    if (this.options.circular && panelManager.getPanelCount() > 0) {\n      this.clonePanels();\n      this.updateClonedPanelPositions();\n    }\n\n    panelManager.chainAllPanels();\n  };\n\n  __proto.getVisibleIndexOf = function (panel) {\n    return findIndex(this.visiblePanels, function (visiblePanel) {\n      return visiblePanel === panel;\n    });\n  };\n\n  __proto.build = function () {\n    this.setElements();\n    this.applyCSSValue();\n    this.setMoveType();\n    this.setAxesInstance();\n    this.refreshPanels();\n    this.setDefaultPanel();\n    this.resize();\n    this.moveToDefaultPanel();\n  };\n\n  __proto.setElements = function () {\n    var state = this.state;\n    var options = this.options;\n    var wrapper = this.flicking.getElement();\n    var classPrefix = options.classPrefix;\n    var viewportCandidate = wrapper.children[0];\n    var hasViewportElement = viewportCandidate && hasClass(viewportCandidate, classPrefix + \"-viewport\");\n    var viewportElement = hasViewportElement ? viewportCandidate : document.createElement(\"div\");\n    var cameraCandidate = hasViewportElement ? viewportElement.children[0] : wrapper.children[0];\n    var hasCameraElement = cameraCandidate && hasClass(cameraCandidate, classPrefix + \"-camera\");\n    var cameraElement = hasCameraElement ? cameraCandidate : document.createElement(\"div\");\n\n    if (!hasCameraElement) {\n      cameraElement.className = classPrefix + \"-camera\";\n      var panelElements = hasViewportElement ? viewportElement.children : wrapper.children; // Make all panels to be a child of camera element\n      // wrapper <- viewport <- camera <- panels[1...n]\n\n      toArray(panelElements).forEach(function (child) {\n        cameraElement.appendChild(child);\n      });\n    } else {\n      state.originalCameraStyle = {\n        className: cameraElement.getAttribute(\"class\"),\n        style: cameraElement.getAttribute(\"style\")\n      };\n    }\n\n    if (!hasViewportElement) {\n      viewportElement.className = classPrefix + \"-viewport\"; // Add viewport element to wrapper\n\n      wrapper.appendChild(viewportElement);\n    } else {\n      state.originalViewportStyle = {\n        className: viewportElement.getAttribute(\"class\"),\n        style: viewportElement.getAttribute(\"style\")\n      };\n    }\n\n    if (!hasCameraElement || !hasViewportElement) {\n      viewportElement.appendChild(cameraElement);\n    }\n\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n    state.isViewportGiven = hasViewportElement;\n    state.isCameraGiven = hasCameraElement;\n  };\n\n  __proto.applyCSSValue = function () {\n    var options = this.options;\n    var viewportElement = this.viewportElement;\n    var cameraElement = this.cameraElement;\n    var viewportStyle = this.viewportElement.style; // Set default css values for each element\n\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n    viewportElement.style.zIndex = \"\" + options.zIndex;\n\n    if (options.horizontal) {\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n\n    if (options.overflow) {\n      viewportStyle.overflow = \"visible\";\n    }\n\n    this.panelManager = new PanelManager(this.cameraElement, options);\n  };\n\n  __proto.setMoveType = function () {\n    var moveType = this.options.moveType;\n\n    switch (moveType.type) {\n      case MOVE_TYPE.SNAP:\n        this.moveType = new Snap(moveType.count);\n        break;\n\n      case MOVE_TYPE.FREE_SCROLL:\n        this.moveType = new FreeScroll();\n        break;\n\n      default:\n        throw new Error(\"moveType is not correct!\");\n    }\n  };\n\n  __proto.setAxesInstance = function () {\n    var state = this.state;\n    var options = this.options;\n    var scrollArea = state.scrollArea;\n    var horizontal = options.horizontal;\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0]\n      }\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true\n    });\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: options.horizontal ? [-1, 0] : [0, -1]\n    });\n    this.axes.connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  };\n\n  __proto.refreshPanels = function () {\n    var _this = this;\n\n    var panelManager = this.panelManager; // Panel elements were attached to camera element by Flicking class\n\n    var panelElements = this.cameraElement.children; // Initialize panels\n\n    var panels = toArray(panelElements).map(function (el, idx) {\n      return new Panel(el, idx, _this);\n    });\n    panelManager.replacePanels(panels, []);\n    this.visiblePanels = panels.filter(function (panel) {\n      return Boolean(panel);\n    });\n  };\n\n  __proto.setDefaultPanel = function () {\n    var options = this.options;\n    var panelManager = this.panelManager;\n    var indexRange = this.panelManager.getRange();\n    var index = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n    this.currentPanel = panelManager.get(index);\n  };\n\n  __proto.clonePanels = function () {\n    var state = this.state;\n    var options = this.options;\n    var panelManager = this.panelManager;\n    var gap = options.gap;\n    var viewportSize = state.size;\n    var firstPanel = panelManager.firstPanel();\n    var lastPanel = panelManager.lastPanel(); // There're no panels exist\n\n    if (!firstPanel) {\n      return;\n    } // For each panels, clone itself while last panel's position + size is below viewport size\n\n\n    var panels = panelManager.originalPanels();\n    var reversedPanels = panels.concat().reverse();\n    var sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + gap;\n    var relativeAnchorPosition = firstPanel.getRelativeAnchorPosition();\n    var relativeHangerPosition = this.getRelativeHangerPosition();\n    var areaPrev = (relativeHangerPosition - relativeAnchorPosition) % sumOriginalPanelSize;\n    var sizeSum = 0;\n    var panelAtLeftBoundary;\n\n    for (var _i = 0, reversedPanels_1 = reversedPanels; _i < reversedPanels_1.length; _i++) {\n      var panel = reversedPanels_1[_i];\n\n      if (!panel) {\n        continue;\n      }\n\n      sizeSum += panel.getSize() + gap;\n\n      if (sizeSum >= areaPrev) {\n        panelAtLeftBoundary = panel;\n        break;\n      }\n    }\n\n    var areaNext = (viewportSize - relativeHangerPosition + relativeAnchorPosition) % sumOriginalPanelSize;\n    sizeSum = 0;\n    var panelAtRightBoundary;\n\n    for (var _a = 0, panels_1 = panels; _a < panels_1.length; _a++) {\n      var panel = panels_1[_a];\n\n      if (!panel) {\n        continue;\n      }\n\n      sizeSum += panel.getSize() + gap;\n\n      if (sizeSum >= areaNext) {\n        panelAtRightBoundary = panel;\n        break;\n      }\n    } // Need one more set of clones on prev area of original panel 0\n\n\n    var needCloneOnPrev = panelAtLeftBoundary.getIndex() !== 0 && panelAtLeftBoundary.getIndex() <= panelAtRightBoundary.getIndex(); // Visible count of panel 0 on first screen\n\n    var panel0OnFirstscreen = Math.ceil((relativeHangerPosition + firstPanel.getSize() - relativeAnchorPosition) / sumOriginalPanelSize) + Math.ceil((viewportSize - relativeHangerPosition + relativeAnchorPosition) / sumOriginalPanelSize) - 1; // duplication\n\n    var cloneCount = panel0OnFirstscreen + (needCloneOnPrev ? 1 : 0);\n    var prevCloneCount = panelManager.getCloneCount();\n    panelManager.setCloneCount(cloneCount);\n\n    if (options.renderExternal) {\n      return;\n    }\n\n    if (cloneCount > prevCloneCount) {\n      var _loop_1 = function _loop_1(cloneIndex) {\n        var clones = panels.map(function (origPanel) {\n          return origPanel.clone(cloneIndex);\n        });\n        var fragment = document.createDocumentFragment();\n        clones.forEach(function (panel) {\n          return fragment.appendChild(panel.getElement());\n        });\n        this_1.cameraElement.appendChild(fragment);\n\n        (_a = this_1.visiblePanels).push.apply(_a, clones.filter(function (clone) {\n          return Boolean(clone);\n        }));\n\n        panelManager.insertClones(cloneIndex, 0, clones);\n\n        var _a;\n      };\n\n      var this_1 = this; // should clone more\n\n      for (var cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        _loop_1(cloneIndex);\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panelManager.removeClonesAfter(cloneCount);\n    }\n  };\n\n  __proto.moveToDefaultPanel = function () {\n    var state = this.state;\n    var panelManager = this.panelManager;\n    var options = this.options;\n    var indexRange = this.panelManager.getRange();\n    var defaultIndex = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n    var defaultPanel = panelManager.get(defaultIndex);\n    var defaultPosition = 0;\n\n    if (defaultPanel) {\n      defaultPosition = defaultPanel.getAnchorPosition() - state.relativeHangerPosition;\n      defaultPosition = this.canSetBoundMode() ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next) : defaultPosition;\n    }\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({\n      flick: defaultPosition\n    }, 0);\n  };\n\n  __proto.updateSize = function () {\n    var state = this.state;\n    var options = this.options;\n    var panels = this.panelManager.originalPanels().filter(function (panel) {\n      return Boolean(panel);\n    });\n    var bbox = this.updateBbox();\n    var prevSize = state.size; // Update size & hanger position\n\n    state.size = options.horizontal ? bbox.width : bbox.height;\n\n    if (prevSize !== state.size) {\n      state.relativeHangerPosition = parseArithmeticExpression(options.hanger, state.size);\n      state.infiniteThreshold = parseArithmeticExpression(options.infiniteThreshold, state.size);\n    }\n\n    if (panels.length <= 0) {\n      return;\n    }\n\n    this.resizePanels(panels);\n  };\n\n  __proto.updateOriginalPanelPositions = function () {\n    var gap = this.options.gap;\n    var panelManager = this.panelManager;\n    var firstPanel = panelManager.firstPanel();\n    var panels = panelManager.originalPanels();\n\n    if (!firstPanel) {\n      return;\n    }\n\n    var currentPanel = this.currentPanel;\n    var nearestPanel = this.nearestPanel;\n    var currentState = this.stateMachine.getState();\n    var scrollArea = this.state.scrollArea; // Update panel position && fit to wrapper\n\n    var nextPanelPos = firstPanel.getPosition();\n    var maintainingPanel = firstPanel;\n\n    if (nearestPanel) {\n      // We should maintain nearestPanel's position\n      var looped = !isBetween(currentState.lastPosition + currentState.delta, scrollArea.prev, scrollArea.next);\n      maintainingPanel = looped ? currentPanel : nearestPanel;\n    } else if (firstPanel.getIndex() > 0) {\n      maintainingPanel = currentPanel;\n    }\n\n    var panelsBeforeMaintainPanel = panels.slice(0, maintainingPanel.getIndex() + (maintainingPanel.getCloneIndex() + 1) * panels.length);\n    var accumulatedSize = panelsBeforeMaintainPanel.reduce(function (total, panel) {\n      return total + panel.getSize() + gap;\n    }, 0);\n    nextPanelPos = maintainingPanel.getPosition() - accumulatedSize;\n    panels.forEach(function (panel) {\n      var newPosition = nextPanelPos;\n      var panelSize = panel.getSize();\n      panel.setPosition(newPosition);\n      nextPanelPos += panelSize + gap;\n    });\n\n    if (!this.options.renderOnlyVisible) {\n      panels.forEach(function (panel) {\n        return panel.setPositionCSS();\n      });\n    }\n  };\n\n  __proto.updateClonedPanelPositions = function () {\n    var state = this.state;\n    var options = this.options;\n    var panelManager = this.panelManager;\n    var clonedPanels = panelManager.clonedPanels().reduce(function (allClones, clones) {\n      return allClones.concat(clones);\n    }, []).filter(function (panel) {\n      return Boolean(panel);\n    });\n    var scrollArea = state.scrollArea;\n    var firstPanel = panelManager.firstPanel();\n    var lastPanel = panelManager.lastPanel();\n\n    if (!firstPanel) {\n      return;\n    }\n\n    var sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap; // Locate all cloned panels linearly first\n\n    for (var _i = 0, clonedPanels_1 = clonedPanels; _i < clonedPanels_1.length; _i++) {\n      var panel = clonedPanels_1[_i];\n      var origPanel = panel.getOriginalPanel();\n      var cloneIndex = panel.getCloneIndex();\n      var cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      var clonedPanelPos = cloneBasePos + origPanel.getPosition();\n      panel.setPosition(clonedPanelPos);\n    }\n\n    var lastReplacePosition = firstPanel.getPosition(); // reverse() pollutes original array, so copy it with concat()\n\n    for (var _a = 0, _b = clonedPanels.concat().reverse(); _a < _b.length; _a++) {\n      var panel = _b[_a];\n      var panelSize = panel.getSize();\n      var replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (replacePosition + panelSize <= scrollArea.prev) {\n        // Replace is not meaningful, as it won't be seen in current scroll area\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n\n    if (!this.options.renderOnlyVisible) {\n      clonedPanels.forEach(function (panel) {\n        panel.setPositionCSS();\n      });\n    }\n  };\n\n  __proto.updateScrollArea = function () {\n    var state = this.state;\n    var panelManager = this.panelManager;\n    var options = this.options;\n    var axes = this.axes; // Set viewport scrollable area\n\n    var firstPanel = panelManager.firstPanel();\n    var lastPanel = panelManager.lastPanel();\n    var relativeHangerPosition = state.relativeHangerPosition;\n\n    if (!firstPanel) {\n      state.scrollArea = {\n        prev: 0,\n        next: 0\n      };\n    } else if (this.canSetBoundMode()) {\n      var sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition();\n\n      if (sumOriginalPanelSize >= state.size) {\n        state.scrollArea = {\n          prev: firstPanel.getPosition(),\n          next: lastPanel.getPosition() + lastPanel.getSize() - state.size\n        };\n      } else {\n        // Find anchor position of set of the combined panels\n        var relAnchorPosOfCombined = parseArithmeticExpression(options.anchor, sumOriginalPanelSize);\n        var anchorPos = firstPanel.getPosition() + clamp(relAnchorPosOfCombined, sumOriginalPanelSize - (state.size - relativeHangerPosition), relativeHangerPosition);\n        state.scrollArea = {\n          prev: anchorPos - relativeHangerPosition,\n          next: anchorPos - relativeHangerPosition\n        };\n      }\n    } else if (options.circular) {\n      var sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap; // Maximum scroll extends to first clone sequence's first panel\n\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: sumOriginalPanelSize + firstPanel.getAnchorPosition() - relativeHangerPosition\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: lastPanel.getAnchorPosition() - relativeHangerPosition\n      };\n    }\n\n    var viewportSize = state.size;\n    var bounce = options.bounce;\n    var parsedBounce;\n\n    if (isArray(bounce)) {\n      parsedBounce = bounce.map(function (val) {\n        return parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce);\n      });\n    } else {\n      var parsedVal = parseArithmeticExpression(bounce, viewportSize, DEFAULT_OPTIONS.bounce);\n      parsedBounce = [parsedVal, parsedVal];\n    } // Update axes range and bounce\n\n\n    var flick = axes.axis.flick;\n    flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    flick.bounce = parsedBounce;\n  };\n\n  __proto.checkNeedPanel = function (axesEvent) {\n    var state = this.state;\n    var options = this.options;\n    var panelManager = this.panelManager;\n    var currentPanel = this.currentPanel;\n    var nearestPanel = this.nearestPanel;\n    var currentState = this.stateMachine.getState();\n\n    if (!options.infinite) {\n      return;\n    }\n\n    var gap = options.gap;\n    var infiniteThreshold = state.infiniteThreshold;\n    var maxLastIndex = panelManager.getLastIndex();\n\n    if (maxLastIndex < 0) {\n      return;\n    }\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      this.triggerNeedPanel({\n        axesEvent: axesEvent,\n        siblingPanel: null,\n        direction: null,\n        indexRange: {\n          min: 0,\n          max: maxLastIndex,\n          length: maxLastIndex + 1\n        }\n      });\n      return;\n    }\n\n    var originalNearestPosition = nearestPanel.getPosition(); // Check next direction\n\n    var checkingPanel = !currentState.holding && !currentState.playing ? currentPanel : nearestPanel;\n\n    while (checkingPanel) {\n      var currentIndex = checkingPanel.getIndex();\n      var nextSibling = checkingPanel.nextSibling;\n      var lastPanel = panelManager.lastPanel();\n      var atLastPanel = currentIndex === lastPanel.getIndex();\n      var nextIndex = !atLastPanel && nextSibling ? nextSibling.getIndex() : maxLastIndex + 1;\n      var currentNearestPosition = nearestPanel.getPosition();\n      var panelRight = checkingPanel.getPosition() + checkingPanel.getSize() - (currentNearestPosition - originalNearestPosition);\n      var cameraNext = state.position + state.size; // There're empty panels between\n\n      var emptyPanelExistsBetween = nextIndex - currentIndex > 1; // Expected prev panel's left position is smaller than camera position\n\n      var overThreshold = panelRight + gap - infiniteThreshold <= cameraNext;\n\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent: axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.NEXT,\n          indexRange: {\n            min: currentIndex + 1,\n            max: nextIndex - 1,\n            length: nextIndex - currentIndex - 1\n          }\n        });\n      } // Trigger needPanel in circular & at max panel index\n\n\n      if (options.circular && currentIndex === maxLastIndex && overThreshold) {\n        var firstPanel = panelManager.firstPanel();\n        var firstIndex = firstPanel ? firstPanel.getIndex() : -1;\n\n        if (firstIndex > 0) {\n          this.triggerNeedPanel({\n            axesEvent: axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.NEXT,\n            indexRange: {\n              min: 0,\n              max: firstIndex - 1,\n              length: firstIndex\n            }\n          });\n        }\n      } // Check whether panels are changed\n\n\n      var lastPanelAfterNeed = panelManager.lastPanel();\n      var atLastPanelAfterNeed = lastPanelAfterNeed && currentIndex === lastPanelAfterNeed.getIndex();\n\n      if (atLastPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.nextSibling;\n    } // Check prev direction\n\n\n    checkingPanel = nearestPanel;\n\n    while (checkingPanel) {\n      var cameraPrev = state.position;\n      var checkingIndex = checkingPanel.getIndex();\n      var prevSibling = checkingPanel.prevSibling;\n      var firstPanel = panelManager.firstPanel();\n      var atFirstPanel = checkingIndex === firstPanel.getIndex();\n      var prevIndex = !atFirstPanel && prevSibling ? prevSibling.getIndex() : -1;\n      var currentNearestPosition = nearestPanel.getPosition();\n      var panelLeft = checkingPanel.getPosition() - (currentNearestPosition - originalNearestPosition); // There're empty panels between\n\n      var emptyPanelExistsBetween = checkingIndex - prevIndex > 1; // Expected prev panel's right position is smaller than camera position\n\n      var overThreshold = panelLeft - gap + infiniteThreshold >= cameraPrev;\n\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent: axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.PREV,\n          indexRange: {\n            min: prevIndex + 1,\n            max: checkingIndex - 1,\n            length: checkingIndex - prevIndex - 1\n          }\n        });\n      } // Trigger needPanel in circular & at panel 0\n\n\n      if (options.circular && checkingIndex === 0 && overThreshold) {\n        var lastPanel = panelManager.lastPanel();\n\n        if (lastPanel && lastPanel.getIndex() < maxLastIndex) {\n          var lastIndex = lastPanel.getIndex();\n          this.triggerNeedPanel({\n            axesEvent: axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.PREV,\n            indexRange: {\n              min: lastIndex + 1,\n              max: maxLastIndex,\n              length: maxLastIndex - lastIndex\n            }\n          });\n        }\n      } // Check whether panels were changed\n\n\n      var firstPanelAfterNeed = panelManager.firstPanel();\n      var atFirstPanelAfterNeed = firstPanelAfterNeed && checkingIndex === firstPanelAfterNeed.getIndex(); // Looped in circular mode\n\n      if (atFirstPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.prevSibling;\n    }\n  };\n\n  __proto.triggerNeedPanel = function (params) {\n    var _this = this;\n\n    var axesEvent = params.axesEvent,\n        siblingPanel = params.siblingPanel,\n        direction = params.direction,\n        indexRange = params.indexRange;\n    var options = this.options;\n    var checkedIndexes = this.state.checkedIndexes;\n    var alreadyTriggered = checkedIndexes.some(function (_a) {\n      var min = _a[0],\n          max = _a[1];\n      return min === indexRange.min || max === indexRange.max;\n    });\n    var hasHandler = this.flicking.hasOn(EVENTS.NEED_PANEL);\n\n    if (alreadyTriggered || !hasHandler) {\n      return;\n    } // Should done before triggering event, as we can directly add panels by event callback\n\n\n    checkedIndexes.push([indexRange.min, indexRange.max]);\n    var index = siblingPanel ? siblingPanel.getIndex() : 0;\n    var isTrusted = axesEvent ? axesEvent.isTrusted : false;\n    this.triggerEvent(EVENTS.NEED_PANEL, axesEvent, isTrusted, {\n      index: index,\n      panel: siblingPanel,\n      direction: direction,\n      range: indexRange,\n      fill: function fill(element) {\n        var panelManager = _this.panelManager;\n\n        if (!siblingPanel) {\n          return _this.insert(panelManager.getRange().max + 1, element);\n        }\n\n        var parsedElements = parseElement(element); // Slice elements to fit size equal to empty spaces\n\n        var elements = direction === DIRECTION.NEXT ? parsedElements.slice(0, indexRange.length) : parsedElements.slice(-indexRange.length);\n\n        if (direction === DIRECTION.NEXT) {\n          if (options.circular && index === panelManager.getLastIndex()) {\n            // needPanel event is triggered on last index, insert at index 0\n            return _this.insert(0, elements);\n          } else {\n            return siblingPanel.insertAfter(elements);\n          }\n        } else if (direction === DIRECTION.PREV) {\n          if (options.circular && index === 0) {\n            // needPanel event is triggered on first index(0), insert at the last index\n            return _this.insert(indexRange.max - elements.length + 1, elements);\n          } else {\n            return siblingPanel.insertBefore(elements);\n          }\n        } else {\n          // direction is null when there're no panels exist\n          return _this.insert(0, elements);\n        }\n      }\n    });\n  };\n\n  __proto.updateVisiblePanels = function () {\n    var state = this.state;\n    var options = this.options;\n    var panelManager = this.panelManager;\n    var currentState = this.stateMachine.getState();\n    var cameraElement = this.cameraElement;\n    var renderExternal = options.renderExternal,\n        renderOnlyVisible = options.renderOnlyVisible;\n\n    if (!renderOnlyVisible) {\n      return;\n    }\n\n    if (!this.nearestPanel) {\n      this.visiblePanels = [];\n\n      while (cameraElement.firstChild) {\n        cameraElement.removeChild(cameraElement.firstChild);\n      }\n\n      return;\n    }\n\n    var prevVisiblePanels = this.visiblePanels;\n    var newVisiblePanels = this.calcVisiblePanels();\n\n    var _a = this.checkVisiblePanelChange(prevVisiblePanels, newVisiblePanels),\n        addedPanels = _a.addedPanels,\n        removedPanels = _a.removedPanels;\n\n    if (addedPanels.length <= 0 && removedPanels.length <= 0) {\n      // Visible panels not changed\n      return;\n    }\n\n    if (currentState.holding) {\n      newVisiblePanels.push.apply(newVisiblePanels, removedPanels);\n    } else {\n      var firstVisiblePanelPos = newVisiblePanels[0].getPosition();\n      state.positionOffset = firstVisiblePanelPos;\n    }\n\n    newVisiblePanels.forEach(function (panel) {\n      panel.setPositionCSS(state.positionOffset);\n    });\n\n    if (!renderExternal) {\n      if (!currentState.holding) {\n        removedPanels.forEach(function (panel) {\n          var panelElement = panel.getElement();\n          panelElement.parentNode && cameraElement.removeChild(panelElement);\n        });\n      }\n\n      var fragment_1 = document.createDocumentFragment();\n      addedPanels.forEach(function (panel) {\n        fragment_1.appendChild(panel.getElement());\n      });\n      cameraElement.appendChild(fragment_1);\n    }\n\n    var firstVisiblePanel = newVisiblePanels[0];\n    var lastVisiblePanel = newVisiblePanels[newVisiblePanels.length - 1];\n\n    var getAbsIndex = function getAbsIndex(panel) {\n      return panel.getIndex() + (panel.getCloneIndex() + 1) * panelManager.getPanelCount();\n    };\n\n    var newVisibleRange = {\n      min: getAbsIndex(firstVisiblePanel),\n      max: getAbsIndex(lastVisiblePanel)\n    };\n    this.visiblePanels = newVisiblePanels;\n    this.flicking.trigger(EVENTS.VISIBLE_CHANGE, {\n      type: EVENTS.VISIBLE_CHANGE,\n      range: newVisibleRange\n    });\n  };\n\n  __proto.checkVisiblePanelChange = function (prevVisiblePanels, newVisiblePanels) {\n    var prevRefCount = prevVisiblePanels.map(function () {\n      return 0;\n    });\n    var newRefCount = newVisiblePanels.map(function () {\n      return 0;\n    });\n    prevVisiblePanels.forEach(function (prevPanel, prevIndex) {\n      newVisiblePanels.forEach(function (newPanel, newIndex) {\n        if (prevPanel === newPanel) {\n          prevRefCount[prevIndex]++;\n          newRefCount[newIndex]++;\n        }\n      });\n    });\n    var removedPanels = prevRefCount.reduce(function (removed, count, index) {\n      return count === 0 ? removed.concat([prevVisiblePanels[index]]) : removed;\n    }, []);\n    var addedPanels = newRefCount.reduce(function (added, count, index) {\n      return count === 0 ? added.concat([newVisiblePanels[index]]) : added;\n    }, []);\n    return {\n      removedPanels: removedPanels,\n      addedPanels: addedPanels\n    };\n  };\n\n  __proto.resizePanels = function (panels) {\n    var options = this.options;\n    var panelBboxes = this.panelBboxes;\n\n    if (options.isEqualSize === true) {\n      if (!panelBboxes[\"default\"]) {\n        var defaultPanel = panels[0];\n        panelBboxes[\"default\"] = defaultPanel.getBbox();\n      }\n\n      var defaultBbox_1 = panelBboxes[\"default\"];\n      panels.forEach(function (panel) {\n        panel.resize(defaultBbox_1);\n      });\n      return;\n    } else if (options.isEqualSize) {\n      var equalSizeClasses_2 = options.isEqualSize;\n      panels.forEach(function (panel) {\n        var overlappedClass = panel.getOverlappedClass(equalSizeClasses_2);\n\n        if (overlappedClass) {\n          panel.resize(panelBboxes[overlappedClass]);\n          panelBboxes[overlappedClass] = panel.getBbox();\n        } else {\n          panel.resize();\n        }\n      });\n      return;\n    }\n\n    panels.forEach(function (panel) {\n      panel.resize();\n    });\n  };\n\n  return Viewport;\n}();\n\nvar tid = \"UA-70842526-24\";\nvar cid = Math.random() * Math.pow(10, 20) / Math.pow(10, 10);\n\nfunction sendEvent(category, action, label) {\n  if (!isBrowser) {\n    return;\n  }\n\n  try {\n    var innerWidth = window.innerWidth;\n    var innerHeight = window.innerHeight;\n    var screen = window.screen || {\n      width: innerWidth,\n      height: innerHeight\n    };\n    var collectInfos = [\"v=1\", \"t=event\", \"dl=\" + location.href, \"ul=\" + (navigator.language || \"en-us\").toLowerCase(), \"de=\" + (document.charset || document.inputEncoding || document.characterSet || \"utf-8\"), \"dr=\" + document.referrer, \"dt=\" + document.title, \"sr=\" + screen.width + \"x\" + screen.height, \"vp=\" + innerWidth + \"x\" + innerHeight, \"ec=\" + category, \"ea=\" + action, \"el=\" + JSON.stringify(label), \"cid=\" + cid, \"tid=\" + tid, \"cd1=3.4.7\", \"z=\" + Math.floor(Math.random() * 10000000)];\n    var req = new XMLHttpRequest();\n    req.open(\"GET\", \"https://www.google-analytics.com/collect?\" + collectInfos.join(\"&\"));\n    req.send();\n  } catch (e) {}\n}\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n/**\r\n * @memberof eg\r\n * @extends eg.Component\r\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\r\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\r\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\r\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\r\n */\n\n\nvar Flicking = /*#__PURE__*/function (_super) {\n  __extends(Flicking, _super);\n  /**\r\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\r\n   * @param options An option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\r\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix of class names will be added for the panels, viewport, and camera.<ko>패널들과 뷰포트, 카메라에 추가될 클래스 이름의 접두사.</ko>\r\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation for animation triggered by manual user input. A higher value means a shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\r\n   * @param {boolean} [options.horizontal=true] The direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\r\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for continuous scrolling.<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능하다.</ko>\r\n   * @param {boolean} [options.infinite=false] Enables infinite mode, which can automatically trigger needPanel until reaching the last panel's index reaches the lastIndex.<ko>무한 모드를 활성화한다. 무한 모드에서는 needPanel 이벤트를 자동으로 트리거한다. 해당 동작은 마지막 패널의 인덱스가 lastIndex와 일치할때까지 일어난다.</ko>\r\n   * @param {number} [options.infiniteThreshold=0] A Threshold from viewport edge before triggering `needPanel` event in infinite mode.<ko>무한 모드에서 `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리.</ko>\r\n   * @param {number} [options.lastIndex=Infinity] Maximum panel index that Flicking can set. Flicking won't trigger `needPanel` when the event's panel index is greater than it.<br/>Also, if the last panel's index reached a given index, you can't add more panels.<ko>Flicking이 설정 가능한 패널의 최대 인덱스. `needPanel` 이벤트에 지정된 인덱스가 최대 패널의 개수보다 같거나 커야 하는 경우에 이벤트를 트리거하지 않게 한다.<br>또한, 마지막 패널의 인덱스가 주어진 인덱스와 동일할 경우, 새로운 패널을 더 이상 추가할 수 없다.</ko>\r\n   * @param {number} [options.threshold=40] Movement threshold to change panel(unit: pixel). It should be dragged above the threshold to change the current panel.<ko>패널 변경을 위한 이동 임계값 (단위: 픽셀). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.</ko>\r\n   * @param {number} [options.duration=100] Duration of the panel movement animation. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\r\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] An easing function applied to the panel movement animation. Default value is `easeOutCubic`.<ko>패널 이동 애니메이션에 적용할 easing함수. 기본값은 `easeOutCubic`이다.</ko>\r\n   * @param {number} [options.defaultIndex=0] Index of the panel to set as default when initializing. A zero-based integer.<ko>초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\r\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices to enable.({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Reference})<ko>활성화할 입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 참고})</ko>\r\n   * @param {number} [options.thresholdAngle=45] The threshold angle value(0 ~ 90).<br>If the input angle from click/touched position is above or below this value in horizontal and vertical mode each, scrolling won't happen.<ko>스크롤 동작을 막기 위한 임계각(0 ~ 90).<br>클릭/터치한 지점으로부터 계산된 사용자 입력의 각도가 horizontal/vertical 모드에서 각각 크거나 작으면, 스크롤 동작이 이루어지지 않는다.</ko>\r\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`.<br>You can set different bounce value for prev/next direction by using array.<br>`number` for px value, and `string` for px, and % value relative to viewport size.(ex - 0, \"10px\", \"20%\")<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.<br>배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정 가능하다.<br>`number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있다.(ex - 0, \"10px\", \"20%\")</ko>\r\n   * @param {boolean} [options.autoResize=false] Whether the `resize` method should be called automatically after a window resize event.<ko>window의 `resize` 이벤트 이후 자동으로 resize()메소드를 호출할지의 여부.</ko>\r\n   * @param {boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\r\n   * @param {number|\"\"} [options.zIndex=2000] z-index value for viewport element.<ko>뷰포트 엘리먼트의 z-index 값.</ko>\r\n   * @param {boolean} [options.bound=false] Prevent the view from going out of the first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\r\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\r\n   * @param {string} [options.hanger=\"50%\"] The reference position of the hanger in the viewport, which hangs panel anchors should be stopped at.<br>It should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign.<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\r\n   * @param {string} [options.anchor=\"50%\"] The reference position of the anchor in panels, which can be hanged by viewport hanger.<br>It should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign.<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\r\n   * @param {number} [options.gap=0] Space value between panels. Should be given in number.(px)<ko>패널간에 부여할 간격의 크기를 나타내는 숫자.(px)</ko>\r\n   * @param {eg.Flicking.MoveTypeOption} [options.moveType=\"snap\"] Movement style by user input. (ex: snap, freeScroll)<ko>사용자 입력에 의한 이동 방식.(ex: snap, freeScroll)</ko>\r\n   * @param {boolean} [options.useOffset=false] Whether to use `offsetWidth`/`offsetHeight` instead of `getBoundingClientRect` for panel/viewport size calculation.<br/>You can use this option to calculate the original panel size when CSS transform is applied to viewport or panel.<br/>⚠️ If panel size is not fixed integer value, there can be a 1px gap between panels.<ko>패널과 뷰포트의 크기를 계산할 때 `offsetWidth`/`offsetHeight`를 `getBoundingClientRect` 대신 사용할지 여부.<br/>패널이나 뷰포트에 CSS transform이 설정되어 있을 때 원래 패널 크기를 계산하려면 옵션을 활성화한다.<br/>⚠️ 패널의 크기가 정수로 고정되어있지 않다면 패널 사이에 1px의 공간이 생길 수 있다.</ko>\r\n   * @param {boolean} [options.renderOnlyVisible] Whether to render visible panels only. This can dramatically increase performance when there're many panels.<ko>보이는 패널만 렌더링할지 여부를 설정한다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있다.</ko>\r\n   * @param {boolean|string[]} [options.isEqualSize] This option indicates whether all panels have the same size(true) of first panel, or it can hold a list of class names that determines panel size.<br/>Enabling this option can increase performance while recalculating panel size.<ko>모든 패널의 크기가 동일한지(true), 혹은 패널 크기를 결정하는 패널 클래스들의 리스트.<br/>이 옵션을 설정하면 패널 크기 재설정시에 성능을 높일 수 있다.</ko>\r\n   * @param {boolean} [options.isConstantSize] Whether all panels have a constant size that won't be changed after resize. Enabling this option can increase performance while recalculating panel size.<ko>모든 패널의 크기가 불변인지의 여부. 이 옵션을 'true'로 설정하면 패널 크기 재설정시에 성능을 높일 수 있다.</ko>\r\n   * @param {boolean} [options.renderExternal] Whether to use external rendering. It will delegate DOM manipulation and can synchronize the rendered state by calling `sync()` method. You can use this option to use in frameworks like React, Vue, Angular, which has its states and rendering methods.<ko>외부 렌더링을 사용할 지의 여부. 이 옵션을 사용시 렌더링을 외부에 위임할 수 있고, `sync()`를 호출하여 그 상태를 동기화할 수 있다. 이 옵션을 사용하여, React, Vue, Angular 등 자체적인 상태와 렌더링 방법을 갖는 프레임워크에 대응할 수 있다.</ko>\r\n   * @param {boolean} [options.collectStatistics=true] Whether to collect statistics on how you are using `Flicking`. These statistical data do not contain any personal information and are used only as a basis for the development of a user-friendly product.<ko>어떻게 `Flicking`을 사용하고 있는지에 대한 통계 수집 여부를 나타낸다. 이 통계자료는 개인정보를 포함하고 있지 않으며 오직 사용자 친화적인 제품으로 발전시키기 위한 근거자료로서 활용한다.</ko>\r\n   */\n\n\n  function Flicking(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.isPanelChangedAtBeforeSync = false;\n    /**\r\n     * Update panels to current state.\r\n     * @ko 패널들을 현재 상태에 맞춰 갱신한다.\r\n     * @method\r\n     * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\r\n     */\n\n    _this.resize = function () {\n      var viewport = _this.viewport;\n      var options = _this.options;\n\n      var wrapper = _this.getElement();\n\n      var allPanels = viewport.panelManager.allPanels();\n\n      if (!options.isConstantSize) {\n        allPanels.forEach(function (panel) {\n          return panel.unCacheBbox();\n        });\n      }\n\n      var shouldResetElements = options.renderOnlyVisible && !options.isConstantSize && options.isEqualSize !== true; // Temporarily set parent's height to prevent scroll (#333)\n\n      var parent = wrapper.parentElement;\n      var origStyle = parent.style.height;\n      parent.style.height = parent.offsetHeight + \"px\";\n      viewport.unCacheBbox(); // This should be done before adding panels, to lower performance issue\n\n      viewport.updateBbox();\n\n      if (shouldResetElements) {\n        viewport.appendUncachedPanelElements(allPanels);\n      }\n\n      viewport.resize();\n      parent.style.height = origStyle;\n      return _this;\n    };\n\n    _this.triggerEvent = function (eventName, axesEvent, isTrusted, params) {\n      if (params === void 0) {\n        params = {};\n      }\n\n      var viewport = _this.viewport;\n      var canceled = true; // Ignore events before viewport is initialized\n\n      if (viewport) {\n        var state = viewport.stateMachine.getState();\n\n        var _a = viewport.getScrollArea(),\n            prev = _a.prev,\n            next = _a.next;\n\n        var pos = viewport.getCameraPosition();\n        var progress = getProgress(pos, [prev, prev, next]);\n\n        if (_this.options.circular) {\n          progress %= 1;\n        }\n\n        canceled = !_super.prototype.trigger.call(_this, eventName, merge({\n          type: eventName,\n          index: _this.getIndex(),\n          panel: _this.getCurrentPanel(),\n          direction: state.direction,\n          holding: state.holding,\n          progress: progress,\n          axesEvent: axesEvent,\n          isTrusted: isTrusted\n        }, params));\n      }\n\n      return {\n        onSuccess: function onSuccess(callback) {\n          if (!canceled) {\n            callback();\n          }\n\n          return this;\n        },\n        onStopped: function onStopped(callback) {\n          if (canceled) {\n            callback();\n          }\n\n          return this;\n        }\n      };\n    }; // Return result of \"move\" event triggered\n\n\n    _this.moveCamera = function (axesEvent) {\n      var viewport = _this.viewport;\n      var state = viewport.stateMachine.getState();\n      var options = _this.options;\n      var pos = axesEvent.pos.flick;\n      var previousPosition = viewport.getCameraPosition();\n\n      if (axesEvent.isTrusted && state.holding) {\n        var inputOffset = options.horizontal ? axesEvent.inputEvent.offsetX : axesEvent.inputEvent.offsetY;\n        var isNextDirection = inputOffset < 0;\n        var cameraChange = pos - previousPosition;\n        var looped = isNextDirection === pos < previousPosition;\n\n        if (options.circular && looped) {\n          // Reached at max/min range of axes\n          var scrollAreaSize = viewport.getScrollAreaSize();\n          cameraChange = (cameraChange > 0 ? -1 : 1) * (scrollAreaSize - Math.abs(cameraChange));\n        }\n\n        var currentDirection = cameraChange === 0 ? state.direction : cameraChange > 0 ? DIRECTION.NEXT : DIRECTION.PREV;\n        state.direction = currentDirection;\n      }\n\n      state.delta += axesEvent.delta.flick;\n      viewport.moveCamera(pos, axesEvent);\n      return _this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted).onStopped(function () {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition, axesEvent);\n      });\n    }; // Set flicking wrapper user provided\n\n\n    var wrapper;\n\n    if (isString(element)) {\n      wrapper = document.querySelector(element);\n\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    _this.wrapper = wrapper; // Override default options\n\n    _this.options = merge({}, DEFAULT_OPTIONS, options); // Override moveType option\n\n    var currentOptions = _this.options;\n    var moveType = currentOptions.moveType;\n\n    if (moveType in DEFAULT_MOVE_TYPE_OPTIONS) {\n      currentOptions.moveType = DEFAULT_MOVE_TYPE_OPTIONS[moveType];\n    } // Make viewport instance with panel container element\n\n\n    _this.viewport = new Viewport(_this, _this.options, _this.triggerEvent);\n\n    _this.listenInput();\n\n    _this.listenResize();\n\n    if (_this.options.collectStatistics) {\n      sendEvent(\"usage\", \"options\", options);\n    }\n\n    return _this;\n  }\n  /**\r\n   * Move to the previous panel if it exists.\r\n   * @ko 이전 패널이 존재시 해당 패널로 이동한다.\r\n   * @param [duration=options.duration] Duration of the panel movement animation.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\r\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\r\n   */\n\n\n  var __proto = Flicking.prototype;\n\n  __proto.prev = function (duration) {\n    var currentPanel = this.getCurrentPanel();\n    var currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      var prevPanel = currentPanel.prev();\n\n      if (prevPanel) {\n        prevPanel.focus(duration);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Move to the next panel if it exists.\r\n   * @ko 다음 패널이 존재시 해당 패널로 이동한다.\r\n   * @param [duration=options.duration] Duration of the panel movement animation(unit: ms).<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\r\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\r\n   */\n\n\n  __proto.next = function (duration) {\n    var currentPanel = this.getCurrentPanel();\n    var currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      var nextPanel = currentPanel.next();\n\n      if (nextPanel) {\n        nextPanel.focus(duration);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Move to the panel of given index.\r\n   * @ko 주어진 인덱스에 해당하는 패널로 이동한다.\r\n   * @param index The index number of the panel to move.<ko>이동할 패널의 인덱스 번호.</ko>\r\n   * @param duration [duration=options.duration] Duration of the panel movement.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\r\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\r\n   */\n\n\n  __proto.moveTo = function (index, duration) {\n    var viewport = this.viewport;\n    var panel = viewport.panelManager.get(index);\n    var state = viewport.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    var anchorPosition = panel.getAnchorPosition();\n    var hangerPosition = viewport.getHangerPosition();\n    var targetPanel = panel;\n\n    if (this.options.circular) {\n      var scrollAreaSize = viewport.getScrollAreaSize(); // Check all three possible locations, find the nearest position among them.\n\n      var possiblePositions = [anchorPosition - scrollAreaSize, anchorPosition, anchorPosition + scrollAreaSize];\n      var nearestPosition = possiblePositions.reduce(function (nearest, current) {\n        return Math.abs(current - hangerPosition) < Math.abs(nearest - hangerPosition) ? current : nearest;\n      }, Infinity) - panel.getRelativeAnchorPosition();\n      var identicals = panel.getIdenticalPanels();\n      var offset = nearestPosition - anchorPosition;\n\n      if (offset > 0) {\n        // First cloned panel is nearest\n        targetPanel = identicals[1];\n      } else if (offset < 0) {\n        // Last cloned panel is nearest\n        targetPanel = identicals[identicals.length - 1];\n      }\n\n      targetPanel = targetPanel.clone(targetPanel.getCloneIndex(), true);\n      targetPanel.setPosition(nearestPosition);\n    }\n\n    var currentIndex = this.getIndex();\n\n    if (hangerPosition === targetPanel.getAnchorPosition() && currentIndex === index) {\n      return this;\n    }\n\n    var eventType = panel.getIndex() === viewport.getCurrentIndex() ? \"\" : EVENTS.CHANGE;\n    viewport.moveTo(targetPanel, viewport.findEstimatedPosition(targetPanel), eventType, null, duration);\n    return this;\n  };\n  /**\r\n   * Return index of the current panel. `-1` if no panel exists.\r\n   * @ko 현재 패널의 인덱스 번호를 반환한다. 패널이 하나도 없을 경우 `-1`을 반환한다.\r\n   * @return Current panel's index, zero-based integer.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\r\n   */\n\n\n  __proto.getIndex = function () {\n    return this.viewport.getCurrentIndex();\n  };\n  /**\r\n   * Return the wrapper element user provided in constructor.\r\n   * @ko 사용자가 생성자에서 제공한 래퍼 엘리먼트를 반환한다.\r\n   * @return Wrapper element user provided.<ko>사용자가 제공한 래퍼 엘리먼트.</ko>\r\n   */\n\n\n  __proto.getElement = function () {\n    return this.wrapper;\n  };\n  /**\r\n   * Return current panel. `null` if no panel exists.\r\n   * @ko 현재 패널을 반환한다. 패널이 하나도 없을 경우 `null`을 반환한다.\r\n   * @return Current panel.<ko>현재 패널.</ko>\r\n   */\n\n\n  __proto.getCurrentPanel = function () {\n    var viewport = this.viewport;\n    var panel = viewport.getCurrentPanel();\n    return panel ? panel : null;\n  };\n  /**\r\n   * Return the panel of given index. `null` if it doesn't exists.\r\n   * @ko 주어진 인덱스에 해당하는 패널을 반환한다. 해당 패널이 존재하지 않을 시 `null`이다.\r\n   * @return Panel of given index.<ko>주어진 인덱스에 해당하는 패널.</ko>\r\n   */\n\n\n  __proto.getPanel = function (index) {\n    var viewport = this.viewport;\n    var panel = viewport.panelManager.get(index);\n    return panel ? panel : null;\n  };\n  /**\r\n   * Return all panels.\r\n   * @ko 모든 패널들을 반환한다.\r\n   * @param - Should include cloned panels or not.<ko>복사된 패널들을 포함할지의 여부.</ko>\r\n   * @return All panels.<ko>모든 패널들.</ko>\r\n   */\n\n\n  __proto.getAllPanels = function (includeClone) {\n    var viewport = this.viewport;\n    var panelManager = viewport.panelManager;\n    var panels = includeClone ? panelManager.allPanels() : panelManager.originalPanels();\n    return panels.filter(function (panel) {\n      return !!panel;\n    });\n  };\n  /**\r\n   * Return the panels currently shown in viewport area.\r\n   * @ko 현재 뷰포트 영역에서 보여지고 있는 패널들을 반환한다.\r\n   * @return Panels currently shown in viewport area.<ko>현재 뷰포트 영역에 보여지는 패널들</ko>\r\n   */\n\n\n  __proto.getVisiblePanels = function () {\n    return this.viewport.calcVisiblePanels();\n  };\n  /**\r\n   * Return length of original panels.\r\n   * @ko 원본 패널의 개수를 반환한다.\r\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\r\n   */\n\n\n  __proto.getPanelCount = function () {\n    return this.viewport.panelManager.getPanelCount();\n  };\n  /**\r\n   * Return how many groups of clones are created.\r\n   * @ko 몇 개의 클론 그룹이 생성되었는지를 반환한다.\r\n   * @return Length of cloned panel groups.<ko>클론된 패널 그룹의 개수</ko>\r\n   */\n\n\n  __proto.getCloneCount = function () {\n    return this.viewport.panelManager.getCloneCount();\n  };\n  /**\r\n   * Get maximum panel index for `infinite` mode.\r\n   * @ko `infinite` 모드에서 적용되는 추가 가능한 패널의 최대 인덱스 값을 반환한다.\r\n   * @see {@link eg.Flicking.FlickingOptions}\r\n   * @return Maximum index of panel that can be added.<ko>최대 추가 가능한 패널의 인덱스.</ko>\r\n   */\n\n\n  __proto.getLastIndex = function () {\n    return this.viewport.panelManager.getLastIndex();\n  };\n  /**\r\n   * Set maximum panel index for `infinite' mode.<br>[needPanel]{@link eg.Flicking#events:needPanel} won't be triggered anymore when last panel's index reaches it.<br>Also, you can't add more panels after it.\r\n   * @ko `infinite` 모드에서 적용되는 패널의 최대 인덱스를 설정한다.<br>마지막 패널의 인덱스가 설정한 값에 도달할 경우 더 이상 [needPanel]{@link eg.Flicking#events:needPanel} 이벤트가 발생되지 않는다.<br>또한, 설정한 인덱스 이후로 새로운 패널을 추가할 수 없다.\r\n   * @param - Maximum panel index.\r\n   * @see {@link eg.Flicking.FlickingOptions}\r\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\r\n   */\n\n\n  __proto.setLastIndex = function (index) {\n    this.viewport.setLastIndex(index);\n    return this;\n  };\n  /**\r\n   * Return panel movement animation.\r\n   * @ko 현재 패널 이동 애니메이션이 진행 중인지를 반환한다.\r\n   * @return Is animating or not.<ko>애니메이션 진행 여부.</ko>\r\n   */\n\n\n  __proto.isPlaying = function () {\n    return this.viewport.stateMachine.getState().playing;\n  };\n  /**\r\n   * Unblock input devices.\r\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\r\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\r\n   */\n\n\n  __proto.enableInput = function () {\n    this.viewport.enable();\n    return this;\n  };\n  /**\r\n   * Block input devices.\r\n   * @ko 입력 장치로부터의 입력을 막는다.\r\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\r\n   */\n\n\n  __proto.disableInput = function () {\n    this.viewport.disable();\n    return this;\n  };\n  /**\r\n   * Get current flicking status. You can restore current state by giving returned value to [setStatus()]{@link eg.Flicking#setStatus}.\r\n   * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있다.\r\n   * @return An object with current status value information.<ko>현재 상태값 정보를 가진 객체.</ko>\r\n   */\n\n\n  __proto.getStatus = function () {\n    var viewport = this.viewport;\n    var panels = viewport.panelManager.originalPanels().filter(function (panel) {\n      return !!panel;\n    }).map(function (panel) {\n      return {\n        html: panel.getElement().outerHTML,\n        index: panel.getIndex()\n      };\n    });\n    return {\n      index: viewport.getCurrentIndex(),\n      panels: panels,\n      position: viewport.getCameraPosition()\n    };\n  };\n  /**\r\n   * Restore to the state of the `status`.\r\n   * @ko `status`의 상태로 복원한다.\r\n   * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드의 반환값을 지정하면 된다.</ko>\r\n   */\n\n\n  __proto.setStatus = function (status) {\n    this.viewport.restore(status);\n  };\n  /**\r\n   * Add plugins that can have different effects on Flicking.\r\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가한다.\r\n   * @param - The plugin(s) to add.<ko>추가할 플러그인(들).</ko>\r\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\r\n   */\n\n\n  __proto.addPlugins = function (plugins) {\n    this.viewport.addPlugins(plugins);\n    return this;\n  };\n  /**\r\n   * Remove plugins from Flicking.\r\n   * @ko 플리킹으로부터 플러그인들을 제거한다.\r\n   * @param - The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\r\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\r\n   */\n\n\n  __proto.removePlugins = function (plugins) {\n    this.viewport.removePlugins(plugins);\n    return this;\n  };\n  /**\r\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\r\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\r\n   * @example\r\n   * const flick = new eg.Flicking(\"#flick\");\r\n   * flick.destroy();\r\n   * console.log(flick.moveTo); // null\r\n   */\n\n\n  __proto.destroy = function (option) {\n    if (option === void 0) {\n      option = {};\n    }\n\n    this.off();\n\n    if (this.options.autoResize) {\n      window.removeEventListener(\"resize\", this.resize);\n    }\n\n    this.viewport.destroy(option); // release resources\n\n    for (var x in this) {\n      this[x] = null;\n    }\n  };\n  /**\r\n   * Add new panels at the beginning of panels.\r\n   * @ko 제일 앞에 새로운 패널을 추가한다.\r\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\r\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\r\n   * @example\r\n   * // Suppose there were no panels at initialization\r\n   * const flicking = new eg.Flicking(\"#flick\");\r\n   * flicking.replace(3, document.createElement(\"div\")); // Add new panel at index 3\r\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 2\r\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Prepended at index 0, 1\r\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 0, pushing every panels behind it.\r\n   */\n\n\n  __proto.prepend = function (element) {\n    var viewport = this.viewport;\n    var parsedElements = parseElement(element);\n    var insertingIndex = Math.max(viewport.panelManager.getRange().min - parsedElements.length, 0);\n    return viewport.insert(insertingIndex, parsedElements);\n  };\n  /**\r\n   * Add new panels at the end of panels.\r\n   * @ko 제일 끝에 새로운 패널을 추가한다.\r\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\r\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\r\n   * @example\r\n   * // Suppose there were no panels at initialization\r\n   * const flicking = new eg.Flicking(\"#flick\");\r\n   * flicking.append(document.createElement(\"div\")); // Appended at index 0\r\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\"); // Appended at index 1\r\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Appended at index 2, 3\r\n   * // Even this is possible\r\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\"); // Appended at index 4, 5\r\n   */\n\n\n  __proto.append = function (element) {\n    var viewport = this.viewport;\n    return viewport.insert(viewport.panelManager.getRange().max + 1, element);\n  };\n  /**\r\n   * Replace existing panels with new panels from given index. If target index is empty, add new panel at target index.\r\n   * @ko 주어진 인덱스로부터의 패널들을 새로운 패널들로 교체한다. 인덱스에 해당하는 자리가 비어있다면, 새로운 패널을 해당 자리에 집어넣는다.\r\n   * @param index - Start index to replace new panels.<ko>새로운 패널들로 교체할 시작 인덱스</ko>\r\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\r\n   * @return Array of created panels by replace.<ko>교체되어 새롭게 추가된 패널들의 배열</ko>\r\n   * @example\r\n   * // Suppose there were no panels at initialization\r\n   * const flicking = new eg.Flicking(\"#flick\");\r\n   *\r\n   * // This will add new panel at index 3,\r\n   * // Index 0, 1, 2 is empty at this moment.\r\n   * // [empty, empty, empty, PANEL]\r\n   * flicking.replace(3, document.createElement(\"div\"));\r\n   *\r\n   * // As index 2 was empty, this will also add new panel at index 2.\r\n   * // [empty, empty, PANEL, PANEL]\r\n   * flicking.replace(2, \"\\<div\\>Panel\\</div\\>\");\r\n   *\r\n   * // Index 3 was not empty, so it will replace previous one.\r\n   * // It will also add new panels at index 4 and 5.\r\n   * // before - [empty, empty, PANEL, PANEL]\r\n   * // after - [empty, empty, PANEL, NEW_PANEL, NEW_PANEL, NEW_PANEL]\r\n   * flicking.replace(3, [\"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\"])\r\n   */\n\n\n  __proto.replace = function (index, element) {\n    return this.viewport.replace(index, element);\n  };\n  /**\r\n   * Remove panel at target index. This will decrease index of panels behind it.\r\n   * @ko `index`에 해당하는 자리의 패널을 제거한다. 수행시 `index` 이후의 패널들의 인덱스가 감소된다.\r\n   * @param index - Index of panel to remove.<ko>제거할 패널의 인덱스</ko>\r\n   * @param {number} [deleteCount=1] - Number of panels to remove from index.<ko>`index` 이후로 제거할 패널의 개수.</ko>\r\n   * @return Array of removed panels<ko>제거된 패널들의 배열</ko>\r\n   */\n\n\n  __proto.remove = function (index, deleteCount) {\n    if (deleteCount === void 0) {\n      deleteCount = 1;\n    }\n\n    return this.viewport.remove(index, deleteCount);\n  };\n  /**\r\n   * Get indexes to render. Should be used with `renderOnlyVisible` option.\r\n   * @private\r\n   * @ko 렌더링이 필요한 인덱스들을 반환한다. `renderOnlyVisible` 옵션과 함께 사용해야 한다.\r\n   * @param - Info object of how panel infos are changed.<ko>패널 정보들의 변경 정보를 담는 오브젝트.</ko>\r\n   * @return Array of indexes to render.<ko>렌더링할 인덱스의 배열</ko>\r\n   */\n\n\n  __proto.getRenderingIndexes = function (diffResult) {\n    var viewport = this.viewport;\n    var visiblePanels = viewport.getVisiblePanels();\n    var maintained = diffResult.maintained.reduce(function (values, _a) {\n      var before = _a[0],\n          after = _a[1];\n      values[before] = after;\n      return values;\n    }, {});\n    var prevPanelCount = diffResult.prevList.length;\n    var panelCount = diffResult.list.length;\n    var added = diffResult.added;\n\n    var getPanelAbsIndex = function getPanelAbsIndex(panel) {\n      return panel.getIndex() + (panel.getCloneIndex() + 1) * prevPanelCount;\n    };\n\n    var visibleIndexes = visiblePanels.map(function (panel) {\n      return getPanelAbsIndex(panel);\n    });\n    visibleIndexes = visibleIndexes.filter(function (val) {\n      return maintained[val % prevPanelCount] != null;\n    }).map(function (val) {\n      var cloneIndex = Math.floor(val / prevPanelCount);\n      var changedIndex = maintained[val % prevPanelCount];\n      return changedIndex + panelCount * cloneIndex;\n    });\n    var renderingPanels = visibleIndexes.concat(added);\n    var allPanels = viewport.panelManager.allPanels();\n    viewport.setVisiblePanels(renderingPanels.map(function (index) {\n      return allPanels[index];\n    }));\n    return renderingPanels;\n  };\n  /**\r\n   * Synchronize info of panels instance with info given by external rendering.\r\n   * @ko 외부 렌더링 방식에 의해 입력받은 패널의 정보와 현재 플리킹이 갖는 패널 정보를 동기화한다.\r\n   * @private\r\n   * @param - Info object of how panel infos are changed.<ko>패널 정보들의 변경 정보를 담는 오브젝트.</ko>\r\n   * @param - Whether called from sync method <ko> sync 메소드로부터 호출됐는지 여부 </ko>\r\n   */\n\n\n  __proto.beforeSync = function (diffInfo) {\n    var _this = this;\n\n    var maintained = diffInfo.maintained,\n        added = diffInfo.added,\n        changed = diffInfo.changed,\n        removed = diffInfo.removed;\n    var viewport = this.viewport;\n    var panelManager = viewport.panelManager;\n    var isCircular = this.options.circular;\n    var cloneCount = panelManager.getCloneCount();\n    var prevClonedPanels = panelManager.clonedPanels(); // Update visible panels\n\n    var newVisiblePanels = viewport.getVisiblePanels().filter(function (panel) {\n      return findIndex(removed, function (index) {\n        return index === panel.getIndex();\n      }) < 0;\n    });\n    viewport.setVisiblePanels(newVisiblePanels); // Did not changed at all\n\n    if (added.length <= 0 && removed.length <= 0 && changed.length <= 0 && cloneCount === prevClonedPanels.length) {\n      return this;\n    }\n\n    var prevOriginalPanels = panelManager.originalPanels();\n    var newPanels = [];\n    var newClones = counter(cloneCount).map(function () {\n      return [];\n    });\n    maintained.forEach(function (_a) {\n      var beforeIdx = _a[0],\n          afterIdx = _a[1];\n      newPanels[afterIdx] = prevOriginalPanels[beforeIdx];\n      newPanels[afterIdx].setIndex(afterIdx);\n    });\n    added.forEach(function (addIndex) {\n      newPanels[addIndex] = new Panel(null, addIndex, _this.viewport);\n    });\n\n    if (isCircular) {\n      counter(cloneCount).forEach(function (groupIndex) {\n        var prevCloneGroup = prevClonedPanels[groupIndex];\n        var newCloneGroup = newClones[groupIndex];\n        maintained.forEach(function (_a) {\n          var beforeIdx = _a[0],\n              afterIdx = _a[1];\n          newCloneGroup[afterIdx] = prevCloneGroup ? prevCloneGroup[beforeIdx] : newPanels[afterIdx].clone(groupIndex, false);\n          newCloneGroup[afterIdx].setIndex(afterIdx);\n        });\n        added.forEach(function (addIndex) {\n          var newPanel = newPanels[addIndex];\n          newCloneGroup[addIndex] = newPanel.clone(groupIndex, false);\n        });\n      });\n    }\n\n    added.forEach(function (index) {\n      viewport.updateCheckedIndexes({\n        min: index,\n        max: index\n      });\n    });\n    removed.forEach(function (index) {\n      viewport.updateCheckedIndexes({\n        min: index - 1,\n        max: index + 1\n      });\n    });\n    var checkedIndexes = viewport.getCheckedIndexes();\n    checkedIndexes.forEach(function (_a, idx) {\n      var min = _a[0],\n          max = _a[1]; // Push checked indexes backward\n\n      var pushedIndex = added.filter(function (index) {\n        return index < min && panelManager.has(index);\n      }).length - removed.filter(function (index) {\n        return index < min;\n      }).length;\n      checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n    }); // Only effective only when there are least one panel which have changed its index\n\n    if (changed.length > 0) {\n      // Removed checked index by changed ones after pushing\n      maintained.forEach(function (_a) {\n        var next = _a[1];\n        viewport.updateCheckedIndexes({\n          min: next,\n          max: next\n        });\n      });\n    }\n\n    panelManager.replacePanels(newPanels, newClones);\n    this.isPanelChangedAtBeforeSync = true;\n  };\n  /**\r\n   * Synchronize info of panels with DOM info given by external rendering.\r\n   * @ko 외부 렌더링 방식에 의해 입력받은 DOM의 정보와 현재 플리킹이 갖는 패널 정보를 동기화 한다.\r\n   * @private\r\n   * @param - Info object of how panel elements are changed.<ko>패널의 DOM 요소들의 변경 정보를 담는 오브젝트.</ko>\r\n   */\n\n\n  __proto.sync = function (diffInfo) {\n    var list = diffInfo.list,\n        maintained = diffInfo.maintained,\n        added = diffInfo.added,\n        changed = diffInfo.changed,\n        removed = diffInfo.removed; // Did not changed at all\n\n    if (added.length <= 0 && removed.length <= 0 && changed.length <= 0) {\n      return this;\n    }\n\n    var viewport = this.viewport;\n    var _a = this.options,\n        renderOnlyVisible = _a.renderOnlyVisible,\n        circular = _a.circular;\n    var panelManager = viewport.panelManager;\n\n    if (!renderOnlyVisible) {\n      var indexRange = panelManager.getRange();\n      var beforeDiffInfo = diffInfo;\n\n      if (circular) {\n        var prevOriginalPanelCount_1 = indexRange.max;\n        var originalPanelCount_1 = list.length / (panelManager.getCloneCount() + 1) >> 0;\n        var originalAdded = added.filter(function (index) {\n          return index < originalPanelCount_1;\n        });\n        var originalRemoved = removed.filter(function (index) {\n          return index <= prevOriginalPanelCount_1;\n        });\n        var originalMaintained = maintained.filter(function (_a) {\n          var beforeIdx = _a[0];\n          return beforeIdx <= prevOriginalPanelCount_1;\n        });\n        var originalChanged = changed.filter(function (_a) {\n          var beforeIdx = _a[0];\n          return beforeIdx <= prevOriginalPanelCount_1;\n        });\n        beforeDiffInfo = {\n          added: originalAdded,\n          maintained: originalMaintained,\n          removed: originalRemoved,\n          changed: originalChanged\n        };\n      }\n\n      this.beforeSync(beforeDiffInfo);\n    }\n\n    var visiblePanels = renderOnlyVisible ? viewport.getVisiblePanels() : this.getAllPanels(true);\n    added.forEach(function (addedIndex) {\n      var addedElement = list[addedIndex];\n      var beforePanel = visiblePanels[addedIndex];\n      beforePanel.setElement(addedElement); // As it can be 0\n\n      beforePanel.unCacheBbox();\n    });\n\n    if (this.isPanelChangedAtBeforeSync) {\n      // Reset visible panels\n      viewport.setVisiblePanels([]);\n      this.isPanelChangedAtBeforeSync = false;\n    }\n\n    viewport.resize();\n    return this;\n  };\n\n  __proto.listenInput = function () {\n    var flicking = this;\n    var viewport = flicking.viewport;\n    var stateMachine = viewport.stateMachine; // Set event context\n\n    flicking.eventContext = {\n      flicking: flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: viewport.stopCamera\n    };\n    var handlers = {};\n\n    var _loop_1 = function _loop_1(key) {\n      var eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = function (e) {\n        return stateMachine.fire(eventType, e, flicking.eventContext);\n      };\n    };\n\n    for (var key in AXES_EVENTS) {\n      _loop_1(key);\n    } // Connect Axes instance with PanInput\n\n\n    flicking.viewport.connectAxesHandler(handlers);\n  };\n\n  __proto.listenResize = function () {\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", this.resize);\n    }\n  };\n  /**\r\n   * Version info string\r\n   * @ko 버전정보 문자열\r\n   * @example\r\n   * eg.Flicking.VERSION;  // ex) 3.0.0\r\n   * @memberof eg.Flicking\r\n   */\n\n\n  Flicking.VERSION = \"3.4.7\";\n  /**\r\n   * Direction constant - \"PREV\" or \"NEXT\"\r\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\r\n   * @type {object}\r\n   * @property {\"PREV\"} PREV - Prev direction from current hanger position.<br/>It's `left(←️)` direction when `horizontal: true`.<br/>Or, `up(↑️)` direction when `horizontal: false`.<ko>현재 행어를 기준으로 이전 방향.<br/>`horizontal: true`일 경우 `왼쪽(←️)` 방향.<br/>`horizontal: false`일 경우 `위쪽(↑️)`방향이다.</ko>\r\n   * @property {\"NEXT\"} NEXT - Next direction from current hanger position.<br/>It's `right(→)` direction when `horizontal: true`.<br/>Or, `down(↓️)` direction when `horizontal: false`.<ko>현재 행어를 기준으로 다음 방향.<br/>`horizontal: true`일 경우 `오른쪽(→)` 방향.<br/>`horizontal: false`일 경우 `아래쪽(↓️)`방향이다.</ko>\r\n   * @example\r\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\r\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\r\n   */\n\n  Flicking.DIRECTION = DIRECTION;\n  /**\r\n   * Event type object with event name strings.\r\n   * @ko 이벤트 이름 문자열들을 담은 객체\r\n   * @type {object}\r\n   * @property {\"holdStart\"} HOLD_START - holdStart event<ko>holdStart 이벤트</ko>\r\n   * @property {\"holdEnd\"} HOLD_END - holdEnd event<ko>holdEnd 이벤트</ko>\r\n   * @property {\"moveStart\"} MOVE_START - moveStart event<ko>moveStart 이벤트</ko>\r\n   * @property {\"move\"} MOVE - move event<ko>move 이벤트</ko>\r\n   * @property {\"moveEnd\"} MOVE_END - moveEnd event<ko>moveEnd 이벤트</ko>\r\n   * @property {\"change\"} CHANGE - change event<ko>change 이벤트</ko>\r\n   * @property {\"restore\"} RESTORE - restore event<ko>restore 이벤트</ko>\r\n   * @property {\"select\"} SELECT - select event<ko>select 이벤트</ko>\r\n   * @property {\"needPanel\"} NEED_PANEL - needPanel event<ko>needPanel 이벤트</ko>\r\n   * @example\r\n   * eg.Flicking.EVENTS.MOVE_START; // \"MOVE_START\"\r\n   */\n\n  Flicking.EVENTS = EVENTS;\n  return Flicking;\n}(Component);\n/**\r\n * Copyright (c) 2015 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */\n\n\nexport default Flicking;\nexport { DEFAULT_OPTIONS, MOVE_TYPE, withFlickingMethods };"],"sourceRoot":""}